#!/bin/bash
# vulcan-workspace-init - Dynamic workspace/monitor binding for multi-monitor setups
# Generates workspace rules and Waybar config based on hyprmon-desc profile order
# Run on login, profile switch, or monitor hotplug events
#
# Workspace scheme: 5 workspaces per monitor, ordered by profile definition
#   Monitor 1 (first in profile): workspaces 1-5
#   Monitor 2: workspaces 6-10
#   Monitor 3: workspaces 11-15
#   Monitor 4: workspaces 16-20
#   Monitor 5: workspaces 21-25

set -euo pipefail

HYPR_CONF_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/hypr"
WAYBAR_CONF_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/waybar"
PROFILE_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/hyprmon-desc/profiles"
WORKSPACE_CONF="$HYPR_CONF_DIR/workspaces.conf"
WAYBAR_WORKSPACES_CONF="$WAYBAR_CONF_DIR/workspaces.json"

# Number of workspaces per monitor
WS_PER_MONITOR=5

log() {
    echo "[vulcan-workspace-init] $*" >&2
}

# Get monitors from a profile file (preserves order defined in profile)
get_profile_monitors() {
    local profile_file="$1"
    if [[ -f "$profile_file" ]]; then
        # Extract monitor names from "monitor = NAME, ..." lines, preserving order
        grep -E "^monitor\s*=" "$profile_file" | \
            grep -v "^monitor\s*=\s*," | \
            sed -E 's/^monitor\s*=\s*([^,]+),.*/\1/' | \
            tr -d ' '
    fi
}

# Get currently connected monitors (fallback if no profile)
get_connected_monitors() {
    hyprctl monitors -j | jq -r '.[].name'
}

# Determine which profile is active based on connected monitors
detect_active_profile() {
    local connected
    connected=$(hyprctl monitors -j | jq -r '.[].name' | sort | tr '\n' ' ')
    local monitor_count
    monitor_count=$(echo "$connected" | wc -w)

    # Match profile by monitor count and presence of key monitors
    case $monitor_count in
        5) echo "desktop" ;;
        4) echo "console" ;;
        2)
            if echo "$connected" | grep -q "eDP-1"; then
                echo "campus"
            else
                echo "desktop"
            fi
            ;;
        1) echo "laptop" ;;
        *) echo "desktop" ;;  # Default to desktop
    esac
}

# Define workspace order for each profile
# Order: Main monitor first, then left-to-right, top-to-bottom
# Note: DP numbers can change on replug - update these if monitors shift
declare -A PROFILE_WORKSPACE_ORDER
PROFILE_WORKSPACE_ORDER[desktop]="DP-12 DP-9 DP-10 DP-4 eDP-1"    # Main curved, left, top, float2, laptop
PROFILE_WORKSPACE_ORDER[console]="DP-12 DP-9 DP-4 eDP-1"          # 4 monitors (no center top)
PROFILE_WORKSPACE_ORDER[campus]="DP-4 eDP-1"                       # Float2 + laptop
PROFILE_WORKSPACE_ORDER[laptop]="eDP-1"                            # Just laptop

# Get monitors in the order they should be assigned workspaces
get_ordered_monitors() {
    local profile="${1:-}"

    # If no profile specified, detect it
    if [[ -z "$profile" ]]; then
        profile=$(detect_active_profile)
        log "Auto-detected profile: $profile"
    fi

    # Get the predefined workspace order for this profile
    local order="${PROFILE_WORKSPACE_ORDER[$profile]:-}"

    if [[ -n "$order" ]]; then
        log "Using workspace order for profile: $profile"
        # Get connected monitors to filter the order
        local connected
        connected=$(get_connected_monitors)

        for mon in $order; do
            if echo "$connected" | grep -q "^${mon}$"; then
                echo "$mon"
            fi
        done
    else
        # Fallback: use profile file order
        local profile_file="$PROFILE_DIR/${profile}.conf"
        if [[ -f "$profile_file" ]]; then
            log "Using monitor order from profile file: $profile"
            local connected
            connected=$(get_connected_monitors)

            while read -r mon; do
                if echo "$connected" | grep -q "^${mon}$"; then
                    echo "$mon"
                fi
            done < <(get_profile_monitors "$profile_file")
        else
            log "No profile found, using connected monitor order"
            get_connected_monitors
        fi
    fi
}

# Generate Hyprland workspace rules
generate_hyprland_config() {
    local monitors=("$@")
    local count=${#monitors[@]}

    cat << 'HEADER'
# =============================================================================
# VulcanOS Dynamic Workspace Configuration
# AUTO-GENERATED by vulcan-workspace-init - DO NOT EDIT MANUALLY
# Regenerate with: vulcan-workspace-init
# =============================================================================

HEADER

    for i in "${!monitors[@]}"; do
        local mon="${monitors[$i]}"
        local ws_start=$((i * WS_PER_MONITOR + 1))
        local ws_end=$((ws_start + WS_PER_MONITOR - 1))

        echo "# Monitor $i: $mon (workspaces $ws_start-$ws_end)"

        # Bind workspaces to this monitor
        for ws in $(seq "$ws_start" "$ws_end"); do
            echo "workspace = $ws, monitor:$mon, default:$([[ $ws -eq $ws_start ]] && echo "true" || echo "false")"
        done
        echo ""
    done

    # Add workspace rules for persistent workspaces
    echo "# Workspace behavior rules"
    echo "workspace = special:magic, gapsout:10, gapsin:5"
}

# Generate Waybar persistent-workspaces JSON fragment
generate_waybar_workspaces() {
    local monitors=("$@")

    echo "{"
    echo '    "persistent-workspaces": {'

    local first=true
    for i in "${!monitors[@]}"; do
        local mon="${monitors[$i]}"
        local ws_start=$((i * WS_PER_MONITOR + 1))
        local ws_end=$((ws_start + WS_PER_MONITOR - 1))

        # Build workspace array
        local ws_array=""
        for ws in $(seq "$ws_start" "$ws_end"); do
            [[ -n "$ws_array" ]] && ws_array+=", "
            ws_array+="$ws"
        done

        [[ "$first" != "true" ]] && echo ","
        first=false
        printf '        "%s": [%s]' "$mon" "$ws_array"
    done

    echo ""
    echo "    }"
    echo "}"
}

# Generate format-icons for workspace numbers
generate_workspace_icons() {
    local monitors=("$@")
    local count=${#monitors[@]}

    echo "{"

    # Generate icons: each monitor's workspaces 1-5 get same icons
    for i in "${!monitors[@]}"; do
        local ws_start=$((i * WS_PER_MONITOR + 1))
        local ws_end=$((ws_start + WS_PER_MONITOR - 1))
        local relative=1

        for ws in $(seq "$ws_start" "$ws_end"); do
            local icon
            case $relative in
                1) icon="󰎤" ;;
                2) icon="󰎧" ;;
                3) icon="󰎪" ;;
                4) icon="󰎭" ;;
                5) icon="󰎱" ;;
            esac
            echo "    \"$ws\": \"$icon\","
            ((relative++))
        done
    done

    echo '    "active": "󰮯",'
    echo '    "default": "󰊠"'
    echo "}"
}

# Update Waybar config with current monitor names for persistent-workspaces
update_waybar_persistent_workspaces() {
    local monitors=("$@")
    local config_file="$WAYBAR_CONF_DIR/config.jsonc"

    if [[ ! -f "$config_file" ]]; then
        log "Waybar config not found, skipping update"
        return 1
    fi

    # Build the new persistent-workspaces JSON
    local new_pw="{"
    local first=true
    for i in "${!monitors[@]}"; do
        local mon="${monitors[$i]}"
        local ws_start=$((i * WS_PER_MONITOR + 1))
        local ws_end=$((ws_start + WS_PER_MONITOR - 1))

        local ws_array=""
        for ws in $(seq "$ws_start" "$ws_end"); do
            [[ -n "$ws_array" ]] && ws_array+=", "
            ws_array+="$ws"
        done

        [[ "$first" != "true" ]] && new_pw+=", "
        first=false
        new_pw+="\"$mon\": [$ws_array]"
    done
    new_pw+="}"

    log "Updating Waybar persistent-workspaces..."

    # Use Python to update the JSONC config (preserves comments)
    python3 << PYEOF
import re
import json

config_path = "$config_file"
new_persistent = $new_pw

with open(config_path, 'r') as f:
    content = f.read()

# Pattern to match the persistent-workspaces block (handles multiline)
pattern = r'"persistent-workspaces"\s*:\s*\{[^}]*\}'
replacement = '"persistent-workspaces": ' + json.dumps(new_persistent, separators=(', ', ': '))

new_content = re.sub(pattern, replacement, content, flags=re.DOTALL)

with open(config_path, 'w') as f:
    f.write(new_content)
PYEOF

    if [[ $? -eq 0 ]]; then
        log "Updated Waybar persistent-workspaces"
    else
        log "Warning: Failed to update Waybar config"
    fi
}

# Initialize workspaces on correct monitors
initialize_workspaces() {
    local monitors=("$@")

    log "Initializing workspaces on monitors..."

    for i in "${!monitors[@]}"; do
        local mon="${monitors[$i]}"
        local ws_start=$((i * WS_PER_MONITOR + 1))

        # Focus monitor and switch to its first workspace
        hyprctl dispatch focusmonitor "$mon" > /dev/null 2>&1
        hyprctl dispatch workspace "$ws_start" > /dev/null 2>&1
        sleep 0.1
    done

    # Return focus to first monitor (main)
    if [[ ${#monitors[@]} -gt 0 ]]; then
        hyprctl dispatch focusmonitor "${monitors[0]}" > /dev/null 2>&1
    fi
}

main() {
    local profile="${1:-}"

    log "Detecting monitors..."

    # Get ordered monitor list based on profile
    mapfile -t monitors < <(get_ordered_monitors "$profile")
    local count=${#monitors[@]}

    if [[ $count -eq 0 ]]; then
        log "ERROR: No monitors detected"
        exit 1
    fi

    log "Found $count monitors: ${monitors[*]}"

    # Ensure directories exist
    mkdir -p "$HYPR_CONF_DIR" "$WAYBAR_CONF_DIR"

    # Generate Hyprland workspace config
    log "Generating $WORKSPACE_CONF..."
    generate_hyprland_config "${monitors[@]}" > "$WORKSPACE_CONF"

    # Generate Waybar workspaces JSON (for reference)
    log "Generating $WAYBAR_WORKSPACES_CONF..."
    generate_waybar_workspaces "${monitors[@]}" > "$WAYBAR_WORKSPACES_CONF"

    # Generate icons JSON for reference
    local icons_file="$WAYBAR_CONF_DIR/workspace-icons.json"
    log "Generating $icons_file..."
    generate_workspace_icons "${monitors[@]}" > "$icons_file"

    # Update Waybar config with current monitor names
    update_waybar_persistent_workspaces "${monitors[@]}"

    # Reload Hyprland config
    if pgrep -x Hyprland > /dev/null; then
        log "Reloading Hyprland configuration..."
        hyprctl reload > /dev/null 2>&1 || true
        sleep 0.3

        # Initialize workspaces on correct monitors
        initialize_workspaces "${monitors[@]}"
    fi

    # Restart Waybar to pick up monitor changes
    if pgrep -x waybar > /dev/null; then
        log "Restarting Waybar..."
        killall waybar 2>/dev/null || true
        sleep 0.3
        waybar &>/dev/null &
    fi

    log "Done! Workspace configuration updated for $count monitors."

    # Print summary
    echo ""
    echo "Monitor → Workspace mapping:"
    for i in "${!monitors[@]}"; do
        local ws_start=$((i * WS_PER_MONITOR + 1))
        local ws_end=$((ws_start + WS_PER_MONITOR - 1))
        printf "  %d. %-12s → workspaces %d-%d\n" "$((i+1))" "${monitors[$i]}" "$ws_start" "$ws_end"
    done
}

main "$@"
