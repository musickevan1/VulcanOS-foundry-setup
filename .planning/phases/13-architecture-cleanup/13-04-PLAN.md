---
phase: 13-architecture-cleanup
plan: 04
type: execute
wave: 3
depends_on: [13-02, 13-03, 13-05]
files_modified:
  - vulcan-appearance-manager/src/app.rs
  - vulcan-appearance-manager/src/components/theme_view.rs
autonomous: false

must_haves:
  truths:
    - "Closing app while previewing keeps the previewed theme (implicit apply)"
    - "Closing app while Idle does nothing special"
    - "User can preview multiple themes, cancel to restore original, then apply desired"
  artifacts:
    - path: "vulcan-appearance-manager/src/app.rs"
      provides: "Window close handler for implicit apply"
      contains: "close-request"
  key_links:
    - from: "window close-request handler"
      to: "ThemeViewMsg::ApplyTheme or direct theme_applier"
      via: "implicit apply on close"
      pattern: "close.*apply|delete.*event"
---

<objective>
Implement implicit apply behavior when closing app while previewing, and verify full workflow.

Purpose: Per CONTEXT.md: "Closing app while previewing = implicit apply (keep the new look)". This ensures users don't lose their preview when closing the window.

Output: Window close handler that applies previewed theme if in Previewing state, plus human verification of complete workflow.
</objective>

<execution_context>
@/home/evan/.claude/get-shit-done/workflows/execute-plan.md
@/home/evan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-architecture-cleanup/13-CONTEXT.md
@.planning/phases/13-architecture-cleanup/13-01-PLAN.md
@.planning/phases/13-architecture-cleanup/13-02-PLAN.md
@.planning/phases/13-architecture-cleanup/13-03-PLAN.md
@.planning/phases/13-architecture-cleanup/13-05-PLAN.md
@vulcan-appearance-manager/src/app.rs
@vulcan-appearance-manager/src/components/theme_view.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add method to query ThemeView preview state</name>
  <files>vulcan-appearance-manager/src/components/theme_view.rs</files>
  <action>
Add output message that ThemeView emits whenever preview state changes:

```rust
#[derive(Debug)]
pub enum ThemeViewOutput {
    ShowToast(String),
    ThemeApplied(String),
    ApplyWallpaper(std::path::PathBuf),
    BindingModeChanged(crate::models::BindingMode),
    RestoreWallpapers(std::collections::HashMap<String, std::path::PathBuf>),
    PreviewStateChanged { is_previewing: bool, theme_id: Option<String> },  // ADD
}
```

Emit this in ThemeSelected handler after state changes to Previewing:
```rust
// After transitioning to Previewing in ThemeSelected (after successful preview):
sender.output(ThemeViewOutput::PreviewStateChanged {
    is_previewing: true,
    theme_id: self.previewing_theme_id.clone(),
}).ok();
```

Emit when switching previews (still previewing but different theme):
```rust
// After switching preview in ThemeSelected:
sender.output(ThemeViewOutput::PreviewStateChanged {
    is_previewing: true,
    theme_id: self.previewing_theme_id.clone(),
}).ok();
```

Emit when transitioning to Idle in CancelPreview and ApplyTheme:
```rust
// After transitioning to Idle in CancelPreview (after cancel_preview().ok()):
sender.output(ThemeViewOutput::PreviewStateChanged {
    is_previewing: false,
    theme_id: None,
}).ok();

// After transitioning to Idle in ApplyTheme (after finish().ok()):
sender.output(ThemeViewOutput::PreviewStateChanged {
    is_previewing: false,
    theme_id: None,
}).ok();
```
  </action>
  <verify>
Run `cargo check -p vulcan-appearance-manager` - compiles
  </verify>
  <done>ThemeView emits PreviewStateChanged output when entering/leaving Previewing state</done>
</task>

<task type="auto">
  <name>Task 2: Track preview state in App coordinator</name>
  <files>vulcan-appearance-manager/src/app.rs</files>
  <action>
Add fields to App struct to track preview state:

```rust
pub struct App {
    // ... existing fields ...
    // Preview state tracking for close-time implicit apply
    is_previewing: bool,
    previewing_theme_id: Option<String>,
}
```

Initialize in init():
```rust
let model = App {
    // ... existing fields ...
    is_previewing: false,
    previewing_theme_id: None,
};
```

Add AppMsg variant:
```rust
#[derive(Debug)]
pub enum AppMsg {
    // ... existing variants ...
    PreviewStateChanged { is_previewing: bool, theme_id: Option<String> },
}
```

Update forward closure:
```rust
ThemeViewOutput::PreviewStateChanged { is_previewing, theme_id } =>
    AppMsg::PreviewStateChanged { is_previewing, theme_id },
```

Add handler:
```rust
AppMsg::PreviewStateChanged { is_previewing, theme_id } => {
    self.is_previewing = is_previewing;
    self.previewing_theme_id = theme_id;
}
```
  </action>
  <verify>
Run `cargo check -p vulcan-appearance-manager` - compiles
  </verify>
  <done>App tracks is_previewing and previewing_theme_id from ThemeView outputs</done>
</task>

<task type="auto">
  <name>Task 3: Add window close handler for implicit apply</name>
  <files>vulcan-appearance-manager/src/app.rs</files>
  <action>
Add close-request handler to the ApplicationWindow in the view! macro.

The GTK4 way to handle window close is via the "close-request" signal which returns bool (true = prevent close, false = allow close).

Update the view! macro:
```rust
view! {
    adw::ApplicationWindow {
        set_title: Some("VulcanOS Appearance Manager"),
        set_default_size: (1000, 700),

        // Handle window close - implicit apply if previewing
        connect_close_request[sender] => move |_window| {
            // Send message to self to handle implicit apply
            sender.input(AppMsg::WindowCloseRequested);
            // Return Propagation::Proceed to allow close
            // (the apply happens sync, so window closes after)
            gtk::glib::Propagation::Proceed
        },

        // ... rest of view ...
    }
}
```

Add AppMsg variant:
```rust
AppMsg::WindowCloseRequested,
```

Add handler:
```rust
AppMsg::WindowCloseRequested => {
    // Implicit apply: if previewing, apply the theme before closing
    if self.is_previewing {
        if let Some(ref theme_id) = self.previewing_theme_id {
            // Apply theme directly via theme_applier
            // (ThemeView may be getting destroyed, so use direct call)
            use crate::services::theme_applier;
            if let Err(e) = theme_applier::apply_theme(theme_id) {
                eprintln!("Implicit apply on close failed: {}", e);
                // Don't block close - theme preview is already visible anyway
            }
        }
    }
}
```

Note: The close-request signal is emitted synchronously before the window closes, so the apply happens before destruction.

Import theme_applier at top of app.rs if not already imported:
```rust
use crate::services::theme_applier;
```
  </action>
  <verify>
Run `cargo check -p vulcan-appearance-manager` - compiles
  </verify>
  <done>Window close-request handler applies previewed theme if is_previewing is true</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete AppState integration with preview/apply/cancel workflow:
1. AppState state machine wired into ThemeViewModel (Plan 01)
2. Action bar with Revealer animation - slides in during preview (Plan 02)
3. Cancel restores original theme AND wallpapers (Plan 03)
4. Apply transitions through Applying state with spinner, rollback on failure (Plan 05)
5. Implicit apply when closing app during preview (Plan 04)
  </what-built>
  <how-to-verify>
1. Build and run the app:
   ```bash
   cd /home/evan/VulcanOS/vulcan-appearance-manager
   cargo build && cargo run
   ```

2. Test preview workflow:
   - Note your current theme (shown in header or by theme with checkmark)
   - Click on a different theme card
   - Verify: Action bar slides in from bottom
   - Verify: Status shows "Applied: [original] / Previewing: [new]"
   - Verify: Desktop theme changes (waybar, etc.)

3. Test multi-preview:
   - While previewing Theme A, click on Theme B
   - Verify: Preview switches to Theme B
   - Verify: Status still shows original as "Applied"

4. Test Cancel:
   - With Theme B previewed, click "Cancel"
   - Verify: Action bar slides out
   - Verify: Desktop reverts to original theme
   - Verify: Original wallpapers restored (check via Wallpapers tab)

5. Test Apply:
   - Click a theme to preview
   - Click "Apply"
   - Verify: Spinner shows briefly
   - Verify: Action bar slides out
   - Verify: Theme persists (close and reopen app)

6. Test implicit apply on close:
   - Click a theme to preview (action bar visible)
   - Close the window (X button)
   - Reopen the app
   - Verify: The previewed theme is now the current theme

7. Test button sensitivity:
   - While NOT previewing: Apply/Cancel buttons should NOT be visible (action bar hidden)
   - While previewing: Apply/Cancel should be enabled
   - (Cannot easily test Applying state since it's fast, but button should disable during it)
  </how-to-verify>
  <resume-signal>Type "approved" if all verifications pass, or describe issues found</resume-signal>
</task>

</tasks>

<verification>
1. `cargo check -p vulcan-appearance-manager` passes
2. `cargo build -p vulcan-appearance-manager` succeeds
3. Human verification of complete workflow (checkpoint task)
</verification>

<success_criteria>
- Closing app while previewing applies the previewed theme (implicit apply)
- App tracks preview state from ThemeView outputs
- All v2.1 ARCH requirements met:
  - ARCH-01: AppState state machine integrated into App coordinator (via ThemeViewModel)
  - ARCH-02: Cancel Preview restores previous wallpaper (via RestoreWallpapers)
  - ARCH-03: Preview/Apply/Cancel buttons respect state transitions
- Full preview/apply/cancel workflow verified by human
</success_criteria>

<output>
After completion, create `.planning/phases/13-architecture-cleanup/13-04-SUMMARY.md`
</output>
