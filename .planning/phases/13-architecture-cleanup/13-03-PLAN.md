---
phase: 13-architecture-cleanup
plan: 03
type: execute
wave: 2
depends_on: [13-01]
files_modified:
  - vulcan-appearance-manager/src/components/theme_view.rs
  - vulcan-appearance-manager/src/app.rs
autonomous: true

must_haves:
  truths:
    - "Cancel restores original theme (theme from before any preview started)"
    - "Cancel restores original wallpapers (per-monitor state before preview)"
    - "Apply transitions to Applying state, then to Idle on success"
    - "Apply updates original_theme_id to newly applied theme"
    - "Closing app while previewing keeps the previewed theme (implicit apply)"
    - "Error state displays message and allows retry or cancel"
  artifacts:
    - path: "vulcan-appearance-manager/src/components/theme_view.rs"
      provides: "Cancel restore logic and Apply state transitions"
      contains: "cancel_preview"
    - path: "vulcan-appearance-manager/src/app.rs"
      provides: "Implicit apply on window close during preview"
      contains: "close-request"
  key_links:
    - from: "CancelPreview handler"
      to: "theme_applier::apply_theme"
      via: "restore from snapshot.theme_id"
      pattern: "snapshot\\.theme_id.*apply_theme"
    - from: "CancelPreview handler"
      to: "WallpaperViewMsg::ApplyProfile"
      via: "restore wallpapers via output message"
      pattern: "RestoreWallpapers|ApplyProfile"
    - from: "ApplyTheme handler"
      to: "app_state.start_apply()"
      via: "state transition"
      pattern: "start_apply"
---

<objective>
Implement Cancel restore logic, Apply state transitions, and implicit apply on app close.

Purpose: Complete the preview/apply/cancel workflow so users can safely preview themes, cancel to restore original state, or apply to persist changes. Closing while previewing keeps the new look (implicit apply per CONTEXT.md).

Output: Fully functional Cancel (restores theme + wallpapers), Apply (with state transitions), and close behavior.
</objective>

<execution_context>
@/home/evan/.claude/get-shit-done/workflows/execute-plan.md
@/home/evan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-architecture-cleanup/13-CONTEXT.md
@.planning/phases/13-architecture-cleanup/13-RESEARCH.md
@vulcan-appearance-manager/src/components/theme_view.rs
@vulcan-appearance-manager/src/app.rs
@vulcan-appearance-manager/src/state.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement CancelPreview with full restore</name>
  <files>vulcan-appearance-manager/src/components/theme_view.rs</files>
  <action>
Add new output message for wallpaper restore:
```rust
#[derive(Debug)]
pub enum ThemeViewOutput {
    ShowToast(String),
    ThemeApplied(String),
    ApplyWallpaper(std::path::PathBuf),
    BindingModeChanged(crate::models::BindingMode),
    RestoreWallpapers(std::collections::HashMap<String, std::path::PathBuf>),  // ADD THIS
}
```

Rewrite the CancelPreview handler to restore from snapshot:
```rust
ThemeViewMsg::CancelPreview => {
    if !self.app_state.is_previewing() {
        // Not in preview state, nothing to cancel
        return;
    }

    // Restore from snapshot
    if let Some(ref snapshot) = self.preview_snapshot {
        // Restore theme
        if let Some(ref theme_id) = snapshot.theme_id {
            if let Err(e) = theme_applier::apply_theme(theme_id) {
                eprintln!("Failed to restore theme: {}", e);
                sender.output(ThemeViewOutput::ShowToast(
                    format!("Failed to restore theme: {}", e)
                )).ok();
            }
        }

        // Restore wallpapers via parent coordinator
        if !snapshot.wallpapers.is_empty() {
            sender.output(ThemeViewOutput::RestoreWallpapers(
                snapshot.wallpapers.clone()
            )).ok();
        }
    }

    // Transition state: Previewing -> Idle
    match self.app_state.clone().cancel_preview() {
        Ok(new_state) => {
            self.app_state = new_state;
            self.preview_snapshot = None;
            self.previewing_theme_id = None;
            sender.output(ThemeViewOutput::ShowToast(
                "Reverted to original theme".to_string()
            )).ok();
        }
        Err(e) => {
            eprintln!("Invalid cancel transition: {}", e);
        }
    }
}
```

This restores both theme AND wallpapers from the original snapshot, then clears preview state.
  </action>
  <verify>
Run `cargo check -p vulcan-appearance-manager` - compiles
  </verify>
  <done>CancelPreview handler restores theme and wallpapers from snapshot, transitions to Idle</done>
</task>

<task type="auto">
  <name>Task 2: Implement ApplyTheme with state transitions</name>
  <files>vulcan-appearance-manager/src/components/theme_view.rs</files>
  <action>
Rewrite the ApplyTheme handler to use state machine transitions:

```rust
ThemeViewMsg::ApplyTheme => {
    if let Some(ref theme) = self.selected_theme {
        // Check if we're in a valid state for apply
        if !self.app_state.is_previewing() && !self.app_state.is_idle() {
            return;
        }

        // Check if theme has a suggested wallpaper (existing binding dialog logic)
        if let Some(wallpaper_path) = resolve_theme_wallpaper(theme) {
            // Show binding dialog (existing logic)
            self.show_binding_dialog(theme.clone(), wallpaper_path, sender.clone());
            return;
        }

        // No wallpaper - apply theme with state transitions
        let theme_id = theme.theme_id.clone();

        // Transition to Applying state
        match self.app_state.clone().start_apply() {
            Ok(new_state) => {
                self.app_state = new_state;

                // Perform apply
                match theme_applier::apply_theme(&theme_id) {
                    Ok(_) => {
                        // Success - transition to Idle
                        match self.app_state.clone().finish() {
                            Ok(final_state) => {
                                self.app_state = final_state;
                                self.preview_snapshot = None;
                                self.previewing_theme_id = None;
                                self.original_theme_id = theme_id.clone();
                                self.theme_browser.emit(ThemeBrowserInput::SetCurrentTheme(theme_id.clone()));
                                sender.output(ThemeViewOutput::ThemeApplied(theme_id)).ok();
                            }
                            Err(e) => {
                                eprintln!("Invalid finish transition: {}", e);
                            }
                        }
                    }
                    Err(e) => {
                        // Apply failed - enter error state
                        self.app_state = self.app_state.clone().fail(
                            format!("Failed to apply: {}", e)
                        );
                        sender.output(ThemeViewOutput::ShowToast(
                            format!("Apply failed: {}", e)
                        )).ok();
                    }
                }
            }
            Err(e) => {
                eprintln!("Cannot apply from current state: {}", e);
            }
        }
    }
}
```

Also update the apply_theme_only() helper method to use state transitions (called from BindingChoice handler):
```rust
fn apply_theme_only(&mut self, theme_id: &str, sender: ComponentSender<Self>) {
    // Transition to Applying state
    match self.app_state.clone().start_apply() {
        Ok(new_state) => {
            self.app_state = new_state;

            match theme_applier::apply_theme(theme_id) {
                Ok(_) => {
                    // Success - transition to Idle
                    match self.app_state.clone().finish() {
                        Ok(final_state) => {
                            self.app_state = final_state;
                            self.preview_snapshot = None;
                            self.previewing_theme_id = None;
                            self.original_theme_id = theme_id.to_string();
                            self.theme_browser.emit(ThemeBrowserInput::SetCurrentTheme(theme_id.to_string()));
                            sender.output(ThemeViewOutput::ShowToast(format!("Applied theme: {}", theme_id))).ok();
                            sender.output(ThemeViewOutput::ThemeApplied(theme_id.to_string())).ok();
                        }
                        Err(e) => {
                            eprintln!("Invalid finish transition: {}", e);
                        }
                    }
                }
                Err(e) => {
                    self.app_state = self.app_state.clone().fail(format!("Failed to apply: {}", e));
                    sender.output(ThemeViewOutput::ShowToast(format!("Apply failed: {}", e))).ok();
                }
            }
        }
        Err(e) => {
            eprintln!("Cannot apply from current state: {}", e);
            sender.output(ThemeViewOutput::ShowToast(format!("Apply failed: {}", e))).ok();
        }
    }
}
```
  </action>
  <verify>
Run `cargo check -p vulcan-appearance-manager` - compiles
  </verify>
  <done>ApplyTheme handler transitions Previewing -> Applying -> Idle, handles errors with Error state</done>
</task>

<task type="auto">
  <name>Task 3: Wire RestoreWallpapers message in App coordinator</name>
  <files>vulcan-appearance-manager/src/app.rs</files>
  <action>
Add handler for RestoreWallpapers output from ThemeView.

Update the match in App's theme_view forward closure:
```rust
let theme_view = ThemeViewModel::builder()
    .launch(())
    .forward(sender.input_sender(), |msg| {
        match msg {
            ThemeViewOutput::ShowToast(text) => AppMsg::ShowToast(text),
            ThemeViewOutput::ThemeApplied(id) => AppMsg::ThemeApplied(id),
            ThemeViewOutput::ApplyWallpaper(path) => AppMsg::ApplyThemeWallpaper(path),
            ThemeViewOutput::BindingModeChanged(mode) => AppMsg::BindingModeChanged(mode),
            ThemeViewOutput::RestoreWallpapers(wallpapers) => AppMsg::RestoreWallpapers(wallpapers),  // ADD
        }
    });
```

Add the AppMsg variant:
```rust
#[derive(Debug)]
pub enum AppMsg {
    // ... existing variants ...
    RestoreWallpapers(HashMap<String, PathBuf>),
}
```

Add the handler:
```rust
AppMsg::RestoreWallpapers(wallpapers) => {
    // Restore wallpapers via wallpaper view's profile apply mechanism
    self.wallpaper_view.emit(WallpaperViewMsg::ApplyProfile(wallpapers));
}
```

This reuses the existing ApplyProfile mechanism which applies per-monitor wallpapers.
  </action>
  <verify>
Run `cargo check -p vulcan-appearance-manager` - compiles
  </verify>
  <done>App coordinator handles RestoreWallpapers by forwarding to wallpaper view</done>
</task>

<task type="auto">
  <name>Task 4: Add DismissError handler for error state recovery</name>
  <files>vulcan-appearance-manager/src/components/theme_view.rs</files>
  <action>
Add a DismissError message to allow user to acknowledge errors and return to preview state (where they can retry or cancel):

```rust
#[derive(Debug)]
pub enum ThemeViewMsg {
    // ... existing variants ...
    DismissError,
}
```

Add handler:
```rust
ThemeViewMsg::DismissError => {
    // Recover from error state back to Previewing (if we have a snapshot) or Idle
    match self.app_state.clone().recover() {
        Ok(new_state) => {
            self.app_state = new_state;
        }
        Err(e) => {
            eprintln!("Cannot recover from error: {}", e);
            // Force back to Idle as fallback
            self.app_state = AppState::Idle;
            self.preview_snapshot = None;
            self.previewing_theme_id = None;
        }
    }
}
```

In the action bar error display (from Plan 02), add a dismiss button or make the error message clickable. The simplest approach is to transition to Idle when user clicks Cancel (which already handles this via cancel_preview transition).

Actually, the Error state's recovery field returns to Idle by default. When in error state, the user can:
1. Click Cancel - which will fail (can't cancel from Error), so we need to handle this
2. Click a "Dismiss" button to recover

Update the Cancel button in action bar to handle both Previewing and Error states:
In the view macro, update Cancel button:
```rust
gtk::Button {
    set_label: "Cancel",
    set_tooltip_text: Some("Revert to original theme and wallpaper"),
    #[watch]
    set_sensitive: (model.app_state.is_previewing() || model.app_state.is_error()) && !model.app_state.is_applying(),
    connect_clicked => ThemeViewMsg::CancelPreview,
},
```

And update CancelPreview handler to also handle Error state:
```rust
ThemeViewMsg::CancelPreview => {
    // Handle Error state - recover first, then cancel
    if self.app_state.is_error() {
        if let Ok(recovered) = self.app_state.clone().recover() {
            self.app_state = recovered;
        }
    }

    if !self.app_state.is_previewing() {
        // Not in preview state, just reset
        self.app_state = AppState::Idle;
        self.preview_snapshot = None;
        self.previewing_theme_id = None;
        return;
    }

    // ... rest of cancel logic from Task 1 ...
}
```

Wait, the Error state's recovery returns to Idle, not Previewing. Per CONTEXT.md: "Apply failure shows inline error, stays in preview mode (user can retry or cancel)". So we need to modify how Error state works.

Actually, the state machine's fail() method sets recovery to Idle. But per CONTEXT.md, we want to stay in preview mode so user can retry. The cleanest approach:
1. Don't use Error state for apply failures (it's overkill for this simple case)
2. Just show a toast message and stay in Previewing state

Simplify: Remove DismissError, keep error display as toast-only. The app_state stays Previewing if apply fails, allowing retry.

Updated ApplyTheme error handling:
```rust
Err(e) => {
    // Apply failed - stay in Previewing state, show error toast
    // Don't transition to Error state - just let user retry
    if let Ok(prev_state) = self.app_state.clone().finish() {
        // finish() from Applying goes to Idle, but we want Previewing
        // Actually, we started from Previewing, went to Applying, apply failed
        // We need to go back to Previewing, not Idle
    }
    // Simpler: transition back to Previewing manually
    if let Some(ref snapshot) = self.preview_snapshot {
        self.app_state = AppState::Previewing { previous: snapshot.clone() };
    } else {
        self.app_state = AppState::Idle;
    }
    sender.output(ThemeViewOutput::ShowToast(
        format!("Apply failed: {}. You can retry or cancel.", e)
    )).ok();
}
```

This keeps user in Previewing state on apply failure, allowing retry or cancel.
  </action>
  <verify>
Run `cargo check -p vulcan-appearance-manager` - compiles
  </verify>
  <done>Apply failure keeps user in Previewing state (via toast), allowing retry or cancel</done>
</task>

</tasks>

<verification>
1. `cargo check -p vulcan-appearance-manager` passes
2. `cargo build -p vulcan-appearance-manager` succeeds
3. Manual test: Preview theme A, click Cancel - reverts to original theme
4. Manual test: Preview theme A, change wallpaper in other tab, click Cancel - reverts both
5. Manual test: Preview theme A, click Apply - theme persists, action bar disappears
6. Manual test: If apply fails (simulate by invalid theme_id), toast shown, can retry
7. Code review: CancelPreview restores from snapshot.theme_id and snapshot.wallpapers
</verification>

<success_criteria>
- Cancel restores original theme from snapshot.theme_id
- Cancel restores original wallpapers via RestoreWallpapers output message
- Cancel transitions Previewing -> Idle and clears snapshot
- Apply transitions Previewing -> Applying -> Idle on success
- Apply failure stays in Previewing with error toast (user can retry or cancel)
- App coordinator routes RestoreWallpapers to wallpaper view
</success_criteria>

<output>
After completion, create `.planning/phases/13-architecture-cleanup/13-03-SUMMARY.md`
</output>
