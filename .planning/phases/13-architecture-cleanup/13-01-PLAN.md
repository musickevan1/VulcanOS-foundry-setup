---
phase: 13-architecture-cleanup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - vulcan-appearance-manager/src/components/theme_view.rs
  - vulcan-appearance-manager/src/state.rs
autonomous: true

must_haves:
  truths:
    - "Clicking theme card while Idle transitions to Previewing state"
    - "Clicking different theme while Previewing keeps original snapshot unchanged"
    - "AppState is_previewing() returns true during preview"
    - "Preview snapshot contains theme ID and per-monitor wallpapers"
  artifacts:
    - path: "vulcan-appearance-manager/src/components/theme_view.rs"
      provides: "AppState state machine integration"
      contains: "app_state: AppState"
    - path: "vulcan-appearance-manager/src/state.rs"
      provides: "PreviewSnapshot with wallpaper query"
      exports: ["PreviewSnapshot", "AppState"]
  key_links:
    - from: "theme_view.rs ThemeSelected handler"
      to: "AppState.start_preview()"
      via: "state transition on first click"
      pattern: "app_state\\.clone\\(\\)\\.start_preview"
    - from: "theme_view.rs"
      to: "wallpaper_backend query_active()"
      via: "snapshot creation"
      pattern: "query_active|get_current_wallpapers"
---

<objective>
Integrate the existing AppState state machine into ThemeViewModel for preview lifecycle management.

Purpose: Enable proper state tracking so UI can react to preview/apply/cancel workflow. This is the foundation for action bar visibility and button sensitivity in Plan 02.

Output: ThemeViewModel with app_state field, preview_snapshot field, and state transitions wired to theme selection.
</objective>

<execution_context>
@/home/evan/.claude/get-shit-done/workflows/execute-plan.md
@/home/evan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-architecture-cleanup/13-CONTEXT.md
@.planning/phases/13-architecture-cleanup/13-RESEARCH.md
@vulcan-appearance-manager/src/state.rs
@vulcan-appearance-manager/src/components/theme_view.rs
@vulcan-appearance-manager/src/services/wallpaper_backend.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AppState and PreviewSnapshot to ThemeViewModel</name>
  <files>vulcan-appearance-manager/src/components/theme_view.rs</files>
  <action>
Add to ThemeViewModel struct:
- `app_state: AppState` field (import from crate::state)
- `preview_snapshot: Option<PreviewSnapshot>` field (import PreviewSnapshot from crate::state)
- `previewing_theme_id: Option<String>` field to track which theme is being previewed

In init():
- Initialize `app_state: AppState::Idle`
- Initialize `preview_snapshot: None`
- Initialize `previewing_theme_id: None`

Add use statement at top: `use crate::state::{AppState, PreviewSnapshot};`
  </action>
  <verify>
Run `cargo check -p vulcan-appearance-manager` - no errors about missing fields or imports
  </verify>
  <done>ThemeViewModel has app_state, preview_snapshot, and previewing_theme_id fields initialized correctly</done>
</task>

<task type="auto">
  <name>Task 2: Create snapshot helper method</name>
  <files>vulcan-appearance-manager/src/components/theme_view.rs</files>
  <action>
**Prerequisite verification:** Confirm `original_theme_id: String` field exists in ThemeViewModel struct. This field already exists (line 51) and is initialized from `theme_applier::get_current_theme()` in init() (line 167).

Add impl block method to ThemeViewModel:

```rust
fn create_preview_snapshot(&self) -> PreviewSnapshot {
    // Query current wallpapers from system
    // Use wallpaper_backend::detect_backend() and query_active()
    use crate::services::wallpaper_backend::detect_backend;
    use std::path::PathBuf;

    let wallpapers = detect_backend()
        .and_then(|backend| backend.query_active())
        .map(|wps| {
            wps.into_iter()
                .map(|(k, v)| (k, PathBuf::from(v)))
                .collect()
        })
        .unwrap_or_default();

    PreviewSnapshot {
        wallpapers,
        theme_id: Some(self.original_theme_id.clone()),
    }
}
```

This queries the live wallpaper state at snapshot time using the detected backend (swww or hyprpaper).
  </action>
  <verify>
1. Run `cargo check -p vulcan-appearance-manager` - no errors, method compiles
2. Confirm `original_theme_id` field exists in ThemeViewModel struct (grep for `original_theme_id:`)
  </verify>
  <done>create_preview_snapshot() method exists and returns PreviewSnapshot with current wallpapers and theme_id from original_theme_id field</done>
</task>

<task type="auto">
  <name>Task 3: Wire state transitions to ThemeSelected handler</name>
  <files>vulcan-appearance-manager/src/components/theme_view.rs</files>
  <action>
Modify the ThemeViewMsg::ThemeSelected handler to use state machine:

```rust
ThemeViewMsg::ThemeSelected(theme) => {
    println!("Selected theme: {}", theme.theme_name);
    self.preview_panel.emit(PreviewPanelInput::SetTheme(Some(theme.clone())));
    self.selected_theme = Some(theme.clone());

    // STATE MACHINE: Handle preview based on current state
    if self.app_state.is_idle() {
        // First click: Idle -> Previewing
        let snapshot = self.create_preview_snapshot();
        match self.app_state.clone().start_preview(snapshot.clone()) {
            Ok(new_state) => {
                self.app_state = new_state;
                self.preview_snapshot = Some(snapshot);
                self.previewing_theme_id = Some(theme.theme_id.clone());

                // Apply preview immediately
                if let Err(e) = theme_applier::preview_theme(&theme.theme_id) {
                    eprintln!("Preview failed: {}", e);
                    sender.output(ThemeViewOutput::ShowToast(format!("Preview failed: {}", e))).ok();
                    // Revert state on failure
                    self.app_state = AppState::Idle;
                    self.preview_snapshot = None;
                    self.previewing_theme_id = None;
                } else {
                    sender.output(ThemeViewOutput::ShowToast(format!("Previewing: {}", theme.theme_name))).ok();
                }
            }
            Err(e) => {
                eprintln!("Invalid state transition: {}", e);
            }
        }
    } else if self.app_state.is_previewing() {
        // Subsequent click: Switch preview, keep ORIGINAL snapshot
        self.previewing_theme_id = Some(theme.theme_id.clone());
        if let Err(e) = theme_applier::preview_theme(&theme.theme_id) {
            eprintln!("Preview switch failed: {}", e);
            sender.output(ThemeViewOutput::ShowToast(format!("Preview failed: {}", e))).ok();
        } else {
            sender.output(ThemeViewOutput::ShowToast(format!("Previewing: {}", theme.theme_name))).ok();
        }
    }
    // If in Applying or Error state, ignore click (handled by button sensitivity)
}
```

This implements the multi-preview handling from CONTEXT.md: clicking different themes keeps the ORIGINAL state to restore, not the previous preview.
  </action>
  <verify>
Run `cargo check -p vulcan-appearance-manager` - compiles without errors
  </verify>
  <done>ThemeSelected handler transitions Idle -> Previewing on first click, switches preview on subsequent clicks while keeping original snapshot</done>
</task>

</tasks>

<verification>
1. `cargo check -p vulcan-appearance-manager` passes
2. `cargo build -p vulcan-appearance-manager` succeeds
3. Code review: ThemeViewModel has app_state field
4. Code review: ThemeSelected handler uses start_preview() for first click
5. Code review: Multi-preview keeps original snapshot (no new snapshot on subsequent clicks)
</verification>

<success_criteria>
- ThemeViewModel struct has app_state: AppState and preview_snapshot: Option<PreviewSnapshot> fields
- create_preview_snapshot() queries current wallpapers from detected backend
- create_preview_snapshot() uses existing original_theme_id field for theme_id
- ThemeSelected handler transitions to Previewing state on first click from Idle
- Subsequent clicks while Previewing switch the preview without creating new snapshot
- Original snapshot preserved for cancel restore (tested in Plan 03)
</success_criteria>

<output>
After completion, create `.planning/phases/13-architecture-cleanup/13-01-SUMMARY.md`
</output>
