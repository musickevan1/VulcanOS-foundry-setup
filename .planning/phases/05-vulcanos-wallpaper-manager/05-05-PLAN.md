---
phase: 05-vulcanos-wallpaper-manager
plan: 05
type: execute
wave: 4
depends_on: ["05-02", "05-03", "05-04"]
files_modified:
  - vulcan-wallpaper-manager/src/components/profile_manager.rs
  - vulcan-wallpaper-manager/src/components/mod.rs
  - vulcan-wallpaper-manager/src/services/profile_storage.rs
  - vulcan-wallpaper-manager/src/services/mod.rs
  - vulcan-wallpaper-manager/src/app.rs
autonomous: true

must_haves:
  truths:
    - "User can save current wallpaper assignments as a named profile"
    - "User can load a saved profile to apply all wallpapers at once"
    - "Profile names match hyprmon-desc profiles (desktop, laptop, campus, etc.)"
  artifacts:
    - path: "vulcan-wallpaper-manager/src/components/profile_manager.rs"
      provides: "Profile save/load UI"
      contains: "DropDown"
    - path: "vulcan-wallpaper-manager/src/services/profile_storage.rs"
      provides: "Profile persistence to ~/.config/vulcan-wallpaper/"
      exports: ["save_profile", "load_profile", "list_profiles"]
  key_links:
    - from: "vulcan-wallpaper-manager/src/services/profile_storage.rs"
      to: "~/.config/vulcan-wallpaper/profiles/"
      via: "fs::write with TOML"
      pattern: "toml::to_string_pretty"
    - from: "vulcan-wallpaper-manager/src/app.rs"
      to: "vulcan-wallpaper-manager/src/components/profile_manager.rs"
      via: "Controller instantiation and output forwarding"
      pattern: "ProfileManagerOutput::ApplyProfile"
---

<objective>
Create profile management system that saves/loads wallpaper configurations matching hyprmon-desc monitor profiles.

Purpose: Enable users to save wallpaper sets per monitor profile and quickly switch between them.
Output: Profile manager UI with save/load/delete functionality, persistent TOML storage, and integration into the main app.
</objective>

<execution_context>
@/home/evan/.claude/get-shit-done/workflows/execute-plan.md
@/home/evan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-vulcanos-wallpaper-manager/05-RESEARCH.md
@.planning/phases/05-vulcanos-wallpaper-manager/05-02-SUMMARY.md
@.planning/phases/05-vulcanos-wallpaper-manager/05-03-SUMMARY.md
@.planning/phases/05-vulcanos-wallpaper-manager/05-04-SUMMARY.md
@dotfiles/scripts/.local/bin/vulcan-wallpaper-menu
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create profile storage service</name>
  <files>
    vulcan-wallpaper-manager/src/services/profile_storage.rs
    vulcan-wallpaper-manager/src/services/mod.rs
  </files>
  <action>
Create profile storage service that integrates with hyprmon-desc profile naming:

services/profile_storage.rs:
```rust
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::fs;
use serde::{Deserialize, Serialize};
use anyhow::{Result, Context};

/// Known hyprmon-desc profile names
pub const KNOWN_PROFILES: &[&str] = &["desktop", "console", "campus", "laptop", "presentation"];

/// Wallpaper profile configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WallpaperProfile {
    pub name: String,
    /// Map of monitor name -> wallpaper path
    pub monitor_wallpapers: HashMap<String, PathBuf>,
    /// Optional description
    #[serde(default)]
    pub description: String,
}

impl WallpaperProfile {
    pub fn new(name: String) -> Self {
        Self {
            name,
            monitor_wallpapers: HashMap::new(),
            description: String::new(),
        }
    }

    pub fn with_wallpapers(name: String, wallpapers: HashMap<String, PathBuf>) -> Self {
        Self {
            name,
            monitor_wallpapers: wallpapers,
            description: String::new(),
        }
    }
}

/// Get the profile configuration directory
pub fn profile_dir() -> PathBuf {
    dirs::config_dir()
        .unwrap_or_else(|| PathBuf::from("~/.config"))
        .join("vulcan-wallpaper")
        .join("profiles")
}

/// Ensure the profile directory exists
pub fn ensure_profile_dir() -> Result<PathBuf> {
    let dir = profile_dir();
    fs::create_dir_all(&dir).context("Failed to create profile directory")?;
    Ok(dir)
}

/// Save a profile to disk
pub fn save_profile(profile: &WallpaperProfile) -> Result<PathBuf> {
    let dir = ensure_profile_dir()?;
    let path = dir.join(format!("{}.toml", profile.name));

    let toml = toml::to_string_pretty(profile)
        .context("Failed to serialize profile")?;

    fs::write(&path, toml)
        .context("Failed to write profile file")?;

    Ok(path)
}

/// Load a profile from disk
pub fn load_profile(name: &str) -> Result<WallpaperProfile> {
    let dir = profile_dir();
    let path = dir.join(format!("{}.toml", name));

    let contents = fs::read_to_string(&path)
        .context("Failed to read profile file")?;

    let profile: WallpaperProfile = toml::from_str(&contents)
        .context("Failed to parse profile TOML")?;

    Ok(profile)
}

/// List all available profiles
pub fn list_profiles() -> Result<Vec<String>> {
    let dir = profile_dir();

    if !dir.exists() {
        return Ok(Vec::new());
    }

    let mut profiles = Vec::new();

    for entry in fs::read_dir(&dir).context("Failed to read profile directory")? {
        let entry = entry?;
        let path = entry.path();

        if path.extension().and_then(|s| s.to_str()) == Some("toml") {
            if let Some(name) = path.file_stem().and_then(|s| s.to_str()) {
                profiles.push(name.to_string());
            }
        }
    }

    profiles.sort();
    Ok(profiles)
}

/// Delete a profile
pub fn delete_profile(name: &str) -> Result<()> {
    let dir = profile_dir();
    let path = dir.join(format!("{}.toml", name));

    if path.exists() {
        fs::remove_file(&path).context("Failed to delete profile")?;
    }

    Ok(())
}

/// Get the current profile name based on monitor count
/// This matches the logic in vulcan-wallpaper-menu
pub fn detect_current_profile() -> Option<String> {
    // Read from cache file if exists
    let cache_file = dirs::cache_dir()
        .map(|d| d.join("vulcan-current-profile"));

    if let Some(path) = cache_file {
        if let Ok(name) = fs::read_to_string(&path) {
            let name = name.trim();
            if !name.is_empty() {
                return Some(name.to_string());
            }
        }
    }

    // Fallback: detect based on monitor count
    if let Ok(output) = std::process::Command::new("hyprctl")
        .args(["monitors", "-j"])
        .output()
    {
        if let Ok(monitors) = serde_json::from_slice::<Vec<serde_json::Value>>(&output.stdout) {
            let count = monitors.len();
            return Some(match count {
                5 => "desktop",
                4 => "console",
                2 => "campus",
                1 => "laptop",
                _ => "desktop",
            }.to_string());
        }
    }

    None
}

/// Save the current profile name to cache
pub fn set_current_profile(name: &str) -> Result<()> {
    if let Some(cache_dir) = dirs::cache_dir() {
        let path = cache_dir.join("vulcan-current-profile");
        fs::write(&path, name).context("Failed to save current profile")?;
    }
    Ok(())
}
```

Update services/mod.rs:
```rust
pub mod hyprctl;
pub mod hyprpaper;
pub mod profile_storage;
pub mod thumbnail;
```
  </action>
  <verify>
cd vulcan-wallpaper-manager && cargo check
  </verify>
  <done>Profile storage service compiles with TOML persistence</done>
</task>

<task type="auto">
  <name>Task 2: Create profile manager component</name>
  <files>
    vulcan-wallpaper-manager/src/components/profile_manager.rs
    vulcan-wallpaper-manager/src/components/mod.rs
  </files>
  <action>
Create profile manager UI component:

components/profile_manager.rs:
```rust
use gtk::prelude::*;
use relm4::prelude::*;
use std::collections::HashMap;
use std::path::PathBuf;

use crate::services::profile_storage::{self, WallpaperProfile, KNOWN_PROFILES};

#[derive(Debug)]
pub enum ProfileManagerInput {
    /// Update with current wallpaper assignments
    UpdateWallpapers(HashMap<String, PathBuf>),
    /// Trigger save dialog
    SaveProfile,
    /// Load selected profile
    LoadProfile,
    /// Delete selected profile
    DeleteProfile,
    /// Profile selected from dropdown
    ProfileSelected(String),
    /// Refresh profile list
    Refresh,
}

#[derive(Debug)]
pub enum ProfileManagerOutput {
    /// Profile loaded - apply these wallpapers
    ApplyProfile(HashMap<String, PathBuf>),
    /// Profile saved successfully
    ProfileSaved(String),
    /// Error occurred
    Error(String),
}

pub struct ProfileManagerModel {
    profiles: Vec<String>,
    selected_profile: Option<String>,
    current_wallpapers: HashMap<String, PathBuf>,
}

#[relm4::component(pub)]
impl SimpleComponent for ProfileManagerModel {
    type Init = ();
    type Input = ProfileManagerInput;
    type Output = ProfileManagerOutput;

    view! {
        gtk::Box {
            set_orientation: gtk::Orientation::Horizontal,
            set_spacing: 8,
            set_margin_all: 4,

            // Profile dropdown
            gtk::DropDown {
                set_tooltip_text: Some("Select profile"),
                set_hexpand: true,

                #[watch]
                set_model: Some(&gtk::StringList::new(&model.profiles.iter().map(|s| s.as_str()).collect::<Vec<_>>())),

                connect_selected_notify[sender] => move |dropdown| {
                    if let Some(model) = dropdown.model() {
                        if let Some(item) = model.item(dropdown.selected()) {
                            if let Some(string_obj) = item.downcast_ref::<gtk::StringObject>() {
                                let name = string_obj.string().to_string();
                                sender.input(ProfileManagerInput::ProfileSelected(name));
                            }
                        }
                    }
                },
            },

            // Load button
            gtk::Button {
                set_icon_name: "document-open-symbolic",
                set_tooltip_text: Some("Load profile"),
                #[watch]
                set_sensitive: model.selected_profile.is_some(),
                connect_clicked => ProfileManagerInput::LoadProfile,
            },

            // Save button
            gtk::Button {
                set_icon_name: "document-save-symbolic",
                set_tooltip_text: Some("Save current as profile"),
                connect_clicked => ProfileManagerInput::SaveProfile,
            },

            // Delete button
            gtk::Button {
                set_icon_name: "user-trash-symbolic",
                set_tooltip_text: Some("Delete profile"),
                #[watch]
                set_sensitive: model.selected_profile.is_some() && !KNOWN_PROFILES.contains(&model.selected_profile.as_deref().unwrap_or("")),
                connect_clicked => ProfileManagerInput::DeleteProfile,
            },
        }
    }

    fn init(
        _init: Self::Init,
        _root: Self::Root,
        _sender: ComponentSender<Self>,
    ) -> ComponentParts<Self> {
        let profiles = profile_storage::list_profiles().unwrap_or_default();

        let model = ProfileManagerModel {
            profiles,
            selected_profile: profile_storage::detect_current_profile(),
            current_wallpapers: HashMap::new(),
        };

        let widgets = view_output!();

        ComponentParts { model, widgets }
    }

    fn update(&mut self, msg: Self::Input, sender: ComponentSender<Self>) {
        match msg {
            ProfileManagerInput::UpdateWallpapers(wallpapers) => {
                self.current_wallpapers = wallpapers;
            }

            ProfileManagerInput::ProfileSelected(name) => {
                self.selected_profile = Some(name);
            }

            ProfileManagerInput::SaveProfile => {
                // Get profile name from selected or prompt
                let name = self.selected_profile.clone()
                    .unwrap_or_else(|| "custom".to_string());

                let profile = WallpaperProfile::with_wallpapers(
                    name.clone(),
                    self.current_wallpapers.clone(),
                );

                match profile_storage::save_profile(&profile) {
                    Ok(_) => {
                        let _ = sender.output(ProfileManagerOutput::ProfileSaved(name.clone()));
                        // Refresh profile list
                        self.profiles = profile_storage::list_profiles().unwrap_or_default();
                        println!("Saved profile: {}", name);
                    }
                    Err(e) => {
                        let _ = sender.output(ProfileManagerOutput::Error(e.to_string()));
                    }
                }
            }

            ProfileManagerInput::LoadProfile => {
                if let Some(name) = &self.selected_profile {
                    match profile_storage::load_profile(name) {
                        Ok(profile) => {
                            let _ = sender.output(ProfileManagerOutput::ApplyProfile(
                                profile.monitor_wallpapers
                            ));
                            println!("Loaded profile: {}", name);
                        }
                        Err(e) => {
                            let _ = sender.output(ProfileManagerOutput::Error(e.to_string()));
                        }
                    }
                }
            }

            ProfileManagerInput::DeleteProfile => {
                if let Some(name) = &self.selected_profile {
                    // Don't allow deleting known profiles
                    if KNOWN_PROFILES.contains(&name.as_str()) {
                        let _ = sender.output(ProfileManagerOutput::Error(
                            format!("Cannot delete built-in profile: {}", name)
                        ));
                        return;
                    }

                    match profile_storage::delete_profile(name) {
                        Ok(_) => {
                            self.profiles = profile_storage::list_profiles().unwrap_or_default();
                            self.selected_profile = None;
                            println!("Deleted profile: {}", name);
                        }
                        Err(e) => {
                            let _ = sender.output(ProfileManagerOutput::Error(e.to_string()));
                        }
                    }
                }
            }

            ProfileManagerInput::Refresh => {
                self.profiles = profile_storage::list_profiles().unwrap_or_default();
            }
        }
    }
}
```

Update components/mod.rs:
```rust
pub mod monitor_layout;
pub mod profile_manager;
pub mod wallpaper_picker;
```
  </action>
  <verify>
cd vulcan-wallpaper-manager && cargo check
  </verify>
  <done>Profile manager component compiles with dropdown and action buttons</done>
</task>

<task type="auto">
  <name>Task 3: Test profile save/load cycle</name>
  <files>
    vulcan-wallpaper-manager/src/services/profile_storage.rs
  </files>
  <action>
Add tests to verify profile storage works correctly:

```rust
// Add to end of services/profile_storage.rs

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;

    #[test]
    fn test_profile_roundtrip() {
        // Create test profile
        let mut wallpapers = HashMap::new();
        wallpapers.insert("eDP-1".to_string(), PathBuf::from("/home/test/wall.png"));
        wallpapers.insert("DP-5".to_string(), PathBuf::from("/home/test/wall2.png"));

        let profile = WallpaperProfile::with_wallpapers(
            "test-roundtrip".to_string(),
            wallpapers.clone(),
        );

        // Save
        let result = save_profile(&profile);
        assert!(result.is_ok());

        // Load
        let loaded = load_profile("test-roundtrip");
        assert!(loaded.is_ok());

        let loaded = loaded.unwrap();
        assert_eq!(loaded.name, "test-roundtrip");
        assert_eq!(loaded.monitor_wallpapers, wallpapers);

        // Cleanup
        let _ = delete_profile("test-roundtrip");
    }

    #[test]
    fn test_list_profiles() {
        let result = list_profiles();
        assert!(result.is_ok());
        // Just verify it doesn't crash
    }

    #[test]
    fn test_known_profiles() {
        assert!(KNOWN_PROFILES.contains(&"desktop"));
        assert!(KNOWN_PROFILES.contains(&"laptop"));
        assert!(KNOWN_PROFILES.contains(&"campus"));
    }
}
```

Run the tests:
```bash
cd vulcan-wallpaper-manager && cargo test profile_storage
```

Also test that the profile directory is created:
```bash
ls -la ~/.config/vulcan-wallpaper/profiles/ 2>/dev/null || echo "Profile dir will be created on first save"
```
  </action>
  <verify>
cd vulcan-wallpaper-manager && cargo test profile_storage
  </verify>
  <done>Profile storage tests pass, profiles persist to TOML files</done>
</task>

<task type="auto">
  <name>Task 4: Integrate profile manager into main app</name>
  <files>
    vulcan-wallpaper-manager/src/app.rs
  </files>
  <action>
Add profile manager component to the main app (extending the app.rs created in Plan 05-04).

1. Add import for profile_manager component:
```rust
use crate::components::profile_manager::{ProfileManagerModel, ProfileManagerInput, ProfileManagerOutput};
```

2. Add profile-related messages to AppMsg:
```rust
#[derive(Debug)]
pub enum AppMsg {
    MonitorSelected(String),
    WallpaperSelected(PathBuf),
    ApplyWallpaper,
    RefreshMonitors,
    OpenDirectory,
    // Profile management messages
    ProfileApply(HashMap<String, PathBuf>),
    ProfileSaved(String),
    ProfileError(String),
}
```

3. Add profile_manager Controller to App struct:
```rust
pub struct App {
    monitors: Vec<Monitor>,
    selected_monitor: Option<String>,
    selected_wallpaper: Option<PathBuf>,
    monitor_wallpapers: HashMap<String, PathBuf>,
    monitor_layout: Controller<MonitorLayoutModel>,
    wallpaper_picker: Controller<WallpaperPickerModel>,
    profile_manager: Controller<ProfileManagerModel>,
}
```

4. In the view! macro, add profile manager widget below the header bar title but still in the header area (or as a separate row above the paned layout):
```rust
// Add to header bar, before the paned content:
pack_start = &gtk::Separator {
    set_orientation: gtk::Orientation::Vertical,
},

// Profile manager in header
pack_start = model.profile_manager.widget() {},
```

5. In init(), create the profile_manager controller:
```rust
// Create profile manager component
let profile_manager = ProfileManagerModel::builder()
    .launch(())
    .forward(sender.input_sender(), |msg| {
        match msg {
            ProfileManagerOutput::ApplyProfile(wallpapers) => AppMsg::ProfileApply(wallpapers),
            ProfileManagerOutput::ProfileSaved(name) => AppMsg::ProfileSaved(name),
            ProfileManagerOutput::Error(e) => AppMsg::ProfileError(e),
        }
    });
```

6. In update(), add handlers for profile messages:
```rust
AppMsg::ProfileApply(wallpapers) => {
    println!("Applying profile with {} wallpapers", wallpapers.len());
    for (monitor, path) in &wallpapers {
        if let Err(e) = hyprpaper::apply_wallpaper(monitor, path) {
            eprintln!("Failed to apply to {}: {}", monitor, e);
        }
    }
    self.monitor_wallpapers.extend(wallpapers);
}

AppMsg::ProfileSaved(name) => {
    println!("Profile saved: {}", name);
}

AppMsg::ProfileError(error) => {
    eprintln!("Profile error: {}", error);
}
```

7. Update the ApplyWallpaper handler to also notify profile manager of wallpaper changes:
```rust
AppMsg::ApplyWallpaper => {
    if let (Some(monitor), Some(path)) = (&self.selected_monitor, &self.selected_wallpaper) {
        match hyprpaper::apply_wallpaper(monitor, path) {
            Ok(()) => {
                println!("Applied {} to {}", path.display(), monitor);
                self.monitor_wallpapers.insert(monitor.clone(), path.clone());
                // Notify profile manager of current wallpaper state
                self.profile_manager.emit(ProfileManagerInput::UpdateWallpapers(
                    self.monitor_wallpapers.clone()
                ));
            }
            Err(e) => {
                eprintln!("Failed to apply wallpaper: {}", e);
            }
        }
    }
}
```
  </action>
  <verify>
cd vulcan-wallpaper-manager && cargo build
  </verify>
  <done>Profile manager integrated into app with message forwarding and wallpaper sync</done>
</task>

</tasks>

<verification>
1. `cargo test profile_storage` passes all tests
2. `cargo build` succeeds with profile manager integration
3. Profile directory created at `~/.config/vulcan-wallpaper/profiles/`
4. Profiles save as valid TOML files
5. Profile manager component renders in header bar with dropdown and buttons
6. Known profiles (desktop, laptop, campus) recognized
7. Loading a profile applies all its wallpapers via hyprpaper
</verification>

<success_criteria>
- Profile storage saves/loads HashMap<String, PathBuf> correctly
- Profile TOML format is human-readable and matches model structure
- Profile manager appears in app header bar
- Profile manager dropdown lists available profiles
- Save button creates new profile with current wallpaper assignments
- Load button applies all wallpapers from selected profile
- Delete button removes profile (except built-in ones)
- Profile detection works based on monitor count or cache file
- Wallpaper changes notify profile manager to update its state
</success_criteria>

<output>
After completion, create `.planning/phases/05-vulcanos-wallpaper-manager/05-05-SUMMARY.md`
</output>
