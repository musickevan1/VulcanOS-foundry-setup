---
phase: 05-vulcanos-wallpaper-manager
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - vulcan-wallpaper-manager/src/main.rs
  - vulcan-wallpaper-manager/src/app.rs
  - vulcan-wallpaper-manager/src/components/mod.rs
  - vulcan-wallpaper-manager/src/components/monitor_layout.rs
autonomous: true

must_haves:
  truths:
    - "Application window opens with AdwApplicationWindow"
    - "Monitor layout widget displays all connected monitors as rectangles"
    - "Monitors are positioned correctly matching actual physical layout"
  artifacts:
    - path: "vulcan-wallpaper-manager/src/app.rs"
      provides: "Main Relm4 application component"
      exports: ["App", "AppMsg"]
    - path: "vulcan-wallpaper-manager/src/components/monitor_layout.rs"
      provides: "Monitor layout visualization widget"
      contains: "DrawingArea"
  key_links:
    - from: "vulcan-wallpaper-manager/src/app.rs"
      to: "vulcan-wallpaper-manager/src/services/hyprctl.rs"
      via: "get_monitors() call on init"
      pattern: "hyprctl::get_monitors"
    - from: "vulcan-wallpaper-manager/src/components/monitor_layout.rs"
      to: "cairo drawing"
      via: "set_draw_func closure"
      pattern: "set_draw_func"
---

<objective>
Build the main application window with Relm4/Adwaita and create the monitor layout visualization component using GTK4 DrawingArea with Cairo.

Purpose: Establish the core UI shell with visual monitor representation that users will interact with.
Output: Working GTK4 window showing scaled monitor layout matching actual desktop configuration.
</objective>

<execution_context>
@/home/evan/.claude/get-shit-done/workflows/execute-plan.md
@/home/evan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-vulcanos-wallpaper-manager/05-RESEARCH.md
@.planning/phases/05-vulcanos-wallpaper-manager/05-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create main Relm4 application component</name>
  <files>
    vulcan-wallpaper-manager/src/main.rs
    vulcan-wallpaper-manager/src/app.rs
  </files>
  <action>
Create src/app.rs with Relm4 SimpleComponent for main application:

```rust
use gtk::prelude::*;
use relm4::prelude::*;
use adw::prelude::*;

use crate::models::Monitor;
use crate::services::hyprctl;
use crate::components::monitor_layout::MonitorLayoutModel;

#[derive(Debug)]
pub enum AppMsg {
    MonitorSelected(String),
    RefreshMonitors,
}

pub struct App {
    monitors: Vec<Monitor>,
    selected_monitor: Option<String>,
    monitor_layout: Controller<MonitorLayoutModel>,
}

#[relm4::component(pub)]
impl SimpleComponent for App {
    type Init = ();
    type Input = AppMsg;
    type Output = ();

    view! {
        adw::ApplicationWindow {
            set_title: Some("VulcanOS Wallpaper Manager"),
            set_default_size: (900, 600),

            adw::ToolbarView {
                add_top_bar = &adw::HeaderBar {
                    #[wrap(Some)]
                    set_title_widget = &adw::WindowTitle {
                        set_title: "Wallpaper Manager",
                        set_subtitle: "Configure per-monitor wallpapers",
                    },
                },

                #[wrap(Some)]
                set_content = &gtk::Box {
                    set_orientation: gtk::Orientation::Vertical,
                    set_spacing: 12,
                    set_margin_all: 12,

                    // Monitor layout visualization
                    gtk::Frame {
                        set_label: Some("Monitor Layout"),
                        set_vexpand: true,

                        model.monitor_layout.widget(),
                    },

                    // Bottom toolbar with actions
                    gtk::Box {
                        set_orientation: gtk::Orientation::Horizontal,
                        set_spacing: 12,
                        set_halign: gtk::Align::End,

                        gtk::Button {
                            set_label: "Refresh",
                            set_icon_name: "view-refresh-symbolic",
                            connect_clicked => AppMsg::RefreshMonitors,
                        },
                    },
                },
            },
        }
    }

    fn init(
        _init: Self::Init,
        root: Self::Root,
        sender: ComponentSender<Self>,
    ) -> ComponentParts<Self> {
        // Load monitors on startup
        let monitors = hyprctl::get_monitors().unwrap_or_default();

        // Create monitor layout component
        let monitor_layout = MonitorLayoutModel::builder()
            .launch(monitors.clone())
            .forward(sender.input_sender(), |msg| {
                match msg {
                    crate::components::monitor_layout::MonitorLayoutOutput::Selected(name) => {
                        AppMsg::MonitorSelected(name)
                    }
                }
            });

        let model = App {
            monitors,
            selected_monitor: None,
            monitor_layout,
        };

        let widgets = view_output!();

        ComponentParts { model, widgets }
    }

    fn update(&mut self, msg: Self::Input, _sender: ComponentSender<Self>) {
        match msg {
            AppMsg::MonitorSelected(name) => {
                self.selected_monitor = Some(name.clone());
                println!("Selected monitor: {}", name);
            }
            AppMsg::RefreshMonitors => {
                if let Ok(monitors) = hyprctl::get_monitors() {
                    self.monitors = monitors.clone();
                    self.monitor_layout.emit(
                        crate::components::monitor_layout::MonitorLayoutInput::UpdateMonitors(monitors)
                    );
                }
            }
        }
    }
}
```

Update main.rs to launch the Relm4 app:

```rust
mod app;
mod components;
mod models;
mod services;

use relm4::RelmApp;
use app::App;

fn main() {
    let app = RelmApp::new("com.vulcanos.wallpaper-manager");
    app.run::<App>(());
}
```
  </action>
  <verify>
cd vulcan-wallpaper-manager && cargo check
  </verify>
  <done>App component compiles with AdwApplicationWindow and header bar</done>
</task>

<task type="auto">
  <name>Task 2: Create monitor layout visualization component</name>
  <files>
    vulcan-wallpaper-manager/src/components/mod.rs
    vulcan-wallpaper-manager/src/components/monitor_layout.rs
  </files>
  <action>
Create src/components/ directory with monitor layout widget.

components/monitor_layout.rs:
```rust
use gtk::prelude::*;
use gtk::glib;
use relm4::prelude::*;
use std::cell::RefCell;
use std::rc::Rc;

use crate::models::Monitor;

#[derive(Debug)]
pub enum MonitorLayoutInput {
    UpdateMonitors(Vec<Monitor>),
    Click(f64, f64),
}

#[derive(Debug)]
pub enum MonitorLayoutOutput {
    Selected(String),
}

pub struct MonitorLayoutModel {
    monitors: Rc<RefCell<Vec<Monitor>>>,
    selected: Option<String>,
}

#[relm4::component(pub)]
impl SimpleComponent for MonitorLayoutModel {
    type Init = Vec<Monitor>;
    type Input = MonitorLayoutInput;
    type Output = MonitorLayoutOutput;

    view! {
        gtk::DrawingArea {
            set_content_width: 600,
            set_content_height: 300,
            set_hexpand: true,
            set_vexpand: true,

            #[watch]
            set_draw_func: {
                let monitors = model.monitors.clone();
                let selected = model.selected.clone();
                move |_area, cr, width, height| {
                    draw_monitors(cr, width, height, &monitors.borrow(), selected.as_deref());
                }
            },

            add_controller = gtk::GestureClick {
                connect_pressed[sender] => move |gesture, _n, x, y| {
                    gesture.set_state(gtk::EventSequenceState::Claimed);
                    sender.input(MonitorLayoutInput::Click(x, y));
                },
            },
        }
    }

    fn init(
        monitors: Self::Init,
        _root: Self::Root,
        _sender: ComponentSender<Self>,
    ) -> ComponentParts<Self> {
        let model = MonitorLayoutModel {
            monitors: Rc::new(RefCell::new(monitors)),
            selected: None,
        };

        let widgets = view_output!();

        ComponentParts { model, widgets }
    }

    fn update(&mut self, msg: Self::Input, sender: ComponentSender<Self>) {
        match msg {
            MonitorLayoutInput::UpdateMonitors(monitors) => {
                *self.monitors.borrow_mut() = monitors;
            }
            MonitorLayoutInput::Click(x, y) => {
                // Find which monitor was clicked
                if let Some(name) = find_monitor_at(&self.monitors.borrow(), x, y, 600.0, 300.0) {
                    self.selected = Some(name.clone());
                    let _ = sender.output(MonitorLayoutOutput::Selected(name));
                }
            }
        }
    }
}

/// Calculate scale factor to fit all monitors in the drawing area
fn calculate_scale(monitors: &[Monitor], width: f64, height: f64) -> (f64, f64, f64) {
    if monitors.is_empty() {
        return (1.0, 0.0, 0.0);
    }

    // Find bounding box of all monitors
    let mut min_x = i32::MAX;
    let mut min_y = i32::MAX;
    let mut max_x = i32::MIN;
    let mut max_y = i32::MIN;

    for mon in monitors {
        let (lw, lh) = mon.logical_size();
        let w = if mon.is_vertical() { lh } else { lw };
        let h = if mon.is_vertical() { lw } else { lh };

        min_x = min_x.min(mon.x);
        min_y = min_y.min(mon.y);
        max_x = max_x.max(mon.x + w as i32);
        max_y = max_y.max(mon.y + h as i32);
    }

    let total_width = (max_x - min_x) as f64;
    let total_height = (max_y - min_y) as f64;

    // Calculate scale to fit with padding
    let padding = 40.0;
    let available_width = width - padding * 2.0;
    let available_height = height - padding * 2.0;

    let scale_x = available_width / total_width;
    let scale_y = available_height / total_height;
    let scale = scale_x.min(scale_y);

    // Calculate offset to center the layout
    let offset_x = (width - total_width * scale) / 2.0 - min_x as f64 * scale;
    let offset_y = (height - total_height * scale) / 2.0 - min_y as f64 * scale;

    (scale, offset_x, offset_y)
}

/// Draw all monitors on the cairo context
fn draw_monitors(
    cr: &gtk::cairo::Context,
    width: i32,
    height: i32,
    monitors: &[Monitor],
    selected: Option<&str>,
) {
    let width = width as f64;
    let height = height as f64;

    // Clear background
    cr.set_source_rgb(0.15, 0.15, 0.18);
    cr.paint().ok();

    let (scale, offset_x, offset_y) = calculate_scale(monitors, width, height);

    for mon in monitors {
        let (lw, lh) = mon.logical_size();
        let (w, h) = if mon.is_vertical() { (lh, lw) } else { (lw, lh) };

        let x = mon.x as f64 * scale + offset_x;
        let y = mon.y as f64 * scale + offset_y;
        let w = w * scale;
        let h = h * scale;

        // Draw monitor rectangle
        cr.rectangle(x, y, w, h);

        // Fill color based on selection
        if selected == Some(&mon.name) {
            cr.set_source_rgb(0.4, 0.6, 0.9); // Selected: blue
        } else {
            cr.set_source_rgb(0.25, 0.28, 0.35); // Normal: dark gray
        }
        cr.fill_preserve().ok();

        // Border
        cr.set_source_rgb(0.5, 0.55, 0.65);
        cr.set_line_width(2.0);
        cr.stroke().ok();

        // Monitor name label
        cr.set_source_rgb(0.9, 0.9, 0.9);
        cr.set_font_size(12.0);

        let text = &mon.name;
        let extents = cr.text_extents(text).unwrap();
        let text_x = x + (w - extents.width()) / 2.0;
        let text_y = y + (h + extents.height()) / 2.0;

        cr.move_to(text_x, text_y);
        cr.show_text(text).ok();

        // Resolution label below name
        let res_text = format!("{}x{}", mon.width, mon.height);
        cr.set_font_size(10.0);
        let res_extents = cr.text_extents(&res_text).unwrap();
        let res_x = x + (w - res_extents.width()) / 2.0;
        let res_y = text_y + 14.0;

        cr.move_to(res_x, res_y);
        cr.show_text(&res_text).ok();
    }
}

/// Find which monitor contains the given point
fn find_monitor_at(
    monitors: &[Monitor],
    click_x: f64,
    click_y: f64,
    width: f64,
    height: f64,
) -> Option<String> {
    let (scale, offset_x, offset_y) = calculate_scale(monitors, width, height);

    for mon in monitors {
        let (lw, lh) = mon.logical_size();
        let (w, h) = if mon.is_vertical() { (lh, lw) } else { (lw, lh) };

        let x = mon.x as f64 * scale + offset_x;
        let y = mon.y as f64 * scale + offset_y;
        let w = w * scale;
        let h = h * scale;

        if click_x >= x && click_x <= x + w && click_y >= y && click_y <= y + h {
            return Some(mon.name.clone());
        }
    }

    None
}
```

components/mod.rs:
```rust
pub mod monitor_layout;
```
  </action>
  <verify>
cd vulcan-wallpaper-manager && cargo build
  </verify>
  <done>Monitor layout component compiles with DrawingArea and click detection</done>
</task>

<task type="auto">
  <name>Task 3: Test window launch and monitor visualization</name>
  <files>
    vulcan-wallpaper-manager/src/main.rs
  </files>
  <action>
Ensure main.rs is complete and test the application:

```rust
mod app;
mod components;
mod models;
mod services;

use relm4::RelmApp;
use app::App;

fn main() {
    let app = RelmApp::new("com.vulcanos.wallpaper-manager");
    app.run::<App>(());
}
```

Build and run the application to verify:
1. Window opens with proper title and Adwaita styling
2. Monitor layout is displayed with all connected monitors
3. Clicking a monitor highlights it
4. Refresh button reloads monitor list

Run `cargo run` and visually verify the window appears correctly.
  </action>
  <verify>
cd vulcan-wallpaper-manager && cargo run &
sleep 3
# Window should be visible - check process is running
pgrep -f vulcan-wallpaper-manager && echo "Application running" || echo "Application failed to start"
  </verify>
  <done>Application window opens, shows monitor layout matching `hyprctl monitors` output</done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds without warnings
2. `cargo run` opens GTK4 window with Adwaita styling
3. Monitor layout shows all monitors from `hyprctl monitors -j`
4. Monitors are positioned correctly (vertical monitors rotated, positions match)
5. Clicking a monitor highlights it in blue
6. Refresh button updates the layout
</verification>

<success_criteria>
- AdwApplicationWindow opens with header bar and title
- Monitor layout widget renders using Cairo DrawingArea
- All monitors from hyprctl are displayed with correct relative positions
- Click detection works - clicking monitor outputs selection message
- Vertical monitors (like DP-10) display with correct orientation
- Window closes cleanly without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-vulcanos-wallpaper-manager/05-02-SUMMARY.md`
</output>
