---
phase: 05-vulcanos-wallpaper-manager
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - vulcan-wallpaper-manager/Cargo.toml
  - vulcan-wallpaper-manager/src/main.rs
  - vulcan-wallpaper-manager/src/models/mod.rs
  - vulcan-wallpaper-manager/src/models/monitor.rs
  - vulcan-wallpaper-manager/src/models/wallpaper.rs
  - vulcan-wallpaper-manager/src/models/profile.rs
  - vulcan-wallpaper-manager/src/services/mod.rs
  - vulcan-wallpaper-manager/src/services/hyprctl.rs
autonomous: true

must_haves:
  truths:
    - "Project compiles with cargo build"
    - "Monitor struct correctly parses hyprctl monitors JSON"
    - "Profile struct serializes/deserializes to TOML"
  artifacts:
    - path: "vulcan-wallpaper-manager/Cargo.toml"
      provides: "Project manifest with GTK4/Relm4 dependencies"
      contains: "relm4"
    - path: "vulcan-wallpaper-manager/src/models/monitor.rs"
      provides: "Monitor data structure from hyprctl"
      exports: ["Monitor"]
    - path: "vulcan-wallpaper-manager/src/services/hyprctl.rs"
      provides: "hyprctl IPC wrapper"
      exports: ["get_monitors"]
  key_links:
    - from: "vulcan-wallpaper-manager/src/services/hyprctl.rs"
      to: "hyprctl monitors -j"
      via: "std::process::Command"
      pattern: "Command::new.*hyprctl.*monitors"
---

<objective>
Create the foundational Rust project structure for vulcan-wallpaper-manager with core data models and hyprctl integration service.

Purpose: Establish the project scaffold with working hyprctl monitor detection before building UI components.
Output: Compilable Rust project with models (Monitor, Wallpaper, Profile) and hyprctl service layer.
</objective>

<execution_context>
@/home/evan/.claude/get-shit-done/workflows/execute-plan.md
@/home/evan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-vulcanos-wallpaper-manager/05-RESEARCH.md
@vulcan-vault/Cargo.toml
@.planning/codebase/CONVENTIONS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create project scaffold with Cargo.toml</name>
  <files>
    vulcan-wallpaper-manager/Cargo.toml
    vulcan-wallpaper-manager/src/main.rs
  </files>
  <action>
Create new Rust project directory `vulcan-wallpaper-manager/` in repository root.

Create Cargo.toml with:
- Package: name="vulcan-wallpaper-manager", version="0.1.0", edition="2021"
- Description: "VulcanOS multi-monitor wallpaper manager with GTK4/Adwaita"
- Authors: ["VulcanOS"]

Dependencies (follow vulcan-vault patterns):
- gtk4 = { version = "0.9", package = "gtk4", features = ["v4_16"] }
- libadwaita = { version = "0.7", package = "libadwaita", features = ["v1_6"] }
- relm4 = { version = "0.9", features = ["libadwaita"] }
- image = "0.25"
- serde = { version = "1.0", features = ["derive"] }
- serde_json = "1.0"
- toml = "0.8"
- anyhow = "1.0"
- dirs = "5"
- tokio = { version = "1", features = ["rt", "process"] }

Create minimal main.rs that:
- Declares modules: mod models; mod services;
- Has placeholder main() that prints "VulcanOS Wallpaper Manager"

Do NOT use gtk4 or relm4 in main.rs yet - that comes in Plan 02.
  </action>
  <verify>
cd vulcan-wallpaper-manager && cargo check
  </verify>
  <done>cargo check passes without errors, Cargo.toml has all required dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Create data models (Monitor, Wallpaper, Profile)</name>
  <files>
    vulcan-wallpaper-manager/src/models/mod.rs
    vulcan-wallpaper-manager/src/models/monitor.rs
    vulcan-wallpaper-manager/src/models/wallpaper.rs
    vulcan-wallpaper-manager/src/models/profile.rs
  </files>
  <action>
Create src/models/ directory with mod.rs barrel file.

models/monitor.rs:
```rust
use serde::Deserialize;

#[derive(Debug, Clone, Deserialize)]
pub struct Monitor {
    pub id: u32,
    pub name: String,
    pub description: String,
    pub make: String,
    pub model: String,
    pub width: u32,      // Physical resolution
    pub height: u32,     // Physical resolution
    pub x: i32,          // Position in layout
    pub y: i32,          // Position in layout
    pub scale: f64,      // HiDPI scaling factor
    pub transform: u32,  // Rotation: 0=normal, 1=90deg, etc.
    pub focused: bool,
}

impl Monitor {
    /// Returns logical dimensions (physical / scale)
    pub fn logical_size(&self) -> (f64, f64) {
        (self.width as f64 / self.scale, self.height as f64 / self.scale)
    }

    /// Returns true if monitor is rotated 90 or 270 degrees
    pub fn is_vertical(&self) -> bool {
        self.transform == 1 || self.transform == 3
    }
}
```

models/wallpaper.rs:
```rust
use std::path::PathBuf;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Wallpaper {
    pub path: PathBuf,
    pub name: String,
}

impl Wallpaper {
    pub fn new(path: PathBuf) -> Self {
        let name = path.file_stem()
            .and_then(|s| s.to_str())
            .unwrap_or("unknown")
            .to_string();
        Self { path, name }
    }
}
```

models/profile.rs:
```rust
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::fs;
use serde::{Deserialize, Serialize};
use anyhow::Result;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WallpaperProfile {
    pub name: String,
    /// Map of monitor name -> wallpaper path
    pub monitor_wallpapers: HashMap<String, PathBuf>,
}

impl WallpaperProfile {
    pub fn new(name: String) -> Self {
        Self {
            name,
            monitor_wallpapers: HashMap::new(),
        }
    }

    pub fn save(&self, profile_dir: &Path) -> Result<()> {
        let path = profile_dir.join(format!("{}.toml", self.name));
        let toml = toml::to_string_pretty(self)?;
        fs::write(&path, toml)?;
        Ok(())
    }

    pub fn load(profile_dir: &Path, name: &str) -> Result<Self> {
        let path = profile_dir.join(format!("{}.toml", name));
        let contents = fs::read_to_string(&path)?;
        let profile: WallpaperProfile = toml::from_str(&contents)?;
        Ok(profile)
    }

    pub fn list_profiles(profile_dir: &Path) -> Result<Vec<String>> {
        let mut profiles = Vec::new();
        if profile_dir.exists() {
            for entry in fs::read_dir(profile_dir)? {
                let entry = entry?;
                let path = entry.path();
                if path.extension().and_then(|s| s.to_str()) == Some("toml") {
                    if let Some(name) = path.file_stem().and_then(|s| s.to_str()) {
                        profiles.push(name.to_string());
                    }
                }
            }
        }
        Ok(profiles)
    }
}
```

models/mod.rs (barrel file):
```rust
mod monitor;
mod wallpaper;
mod profile;

pub use monitor::Monitor;
pub use wallpaper::Wallpaper;
pub use profile::WallpaperProfile;
```
  </action>
  <verify>
cd vulcan-wallpaper-manager && cargo check
  </verify>
  <done>All model files compile, types exported via mod.rs barrel file</done>
</task>

<task type="auto">
  <name>Task 3: Create hyprctl service layer</name>
  <files>
    vulcan-wallpaper-manager/src/services/mod.rs
    vulcan-wallpaper-manager/src/services/hyprctl.rs
  </files>
  <action>
Create src/services/ directory with hyprctl wrapper.

services/hyprctl.rs:
```rust
use std::process::Command;
use anyhow::{Result, Context};
use crate::models::Monitor;

/// Get list of connected monitors from hyprctl
pub fn get_monitors() -> Result<Vec<Monitor>> {
    let output = Command::new("hyprctl")
        .args(["monitors", "-j"])
        .output()
        .context("Failed to execute hyprctl")?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        anyhow::bail!("hyprctl failed: {}", stderr);
    }

    let monitors: Vec<Monitor> = serde_json::from_slice(&output.stdout)
        .context("Failed to parse monitor JSON")?;

    Ok(monitors)
}

/// Preload wallpaper into hyprpaper
pub fn preload_wallpaper(path: &str) -> Result<()> {
    let output = Command::new("hyprctl")
        .args(["hyprpaper", "preload", path])
        .output()
        .context("Failed to execute hyprctl hyprpaper preload")?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        anyhow::bail!("hyprpaper preload failed: {}", stderr);
    }
    Ok(())
}

/// Set wallpaper for a specific monitor
pub fn set_wallpaper(monitor: &str, path: &str) -> Result<()> {
    let arg = format!("{},{}", monitor, path);
    let output = Command::new("hyprctl")
        .args(["hyprpaper", "wallpaper", &arg])
        .output()
        .context("Failed to execute hyprctl hyprpaper wallpaper")?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        anyhow::bail!("hyprpaper set wallpaper failed: {}", stderr);
    }
    Ok(())
}

/// Unload wallpaper from hyprpaper to free memory
pub fn unload_wallpaper(path: &str) -> Result<()> {
    let output = Command::new("hyprctl")
        .args(["hyprpaper", "unload", path])
        .output()
        .context("Failed to execute hyprctl hyprpaper unload")?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        anyhow::bail!("hyprpaper unload failed: {}", stderr);
    }
    Ok(())
}

/// List currently active wallpapers
pub fn list_active_wallpapers() -> Result<Vec<(String, String)>> {
    let output = Command::new("hyprctl")
        .args(["hyprpaper", "listactive"])
        .output()
        .context("Failed to execute hyprctl hyprpaper listactive")?;

    let stdout = String::from_utf8_lossy(&output.stdout);
    let wallpapers: Vec<(String, String)> = stdout
        .lines()
        .filter_map(|line| {
            let parts: Vec<&str> = line.split(" = ").collect();
            if parts.len() == 2 {
                Some((parts[0].to_string(), parts[1].to_string()))
            } else {
                None
            }
        })
        .collect();

    Ok(wallpapers)
}
```

services/mod.rs (barrel file):
```rust
pub mod hyprctl;
```

Update main.rs to test the hyprctl service:
```rust
mod models;
mod services;

use anyhow::Result;

fn main() -> Result<()> {
    println!("VulcanOS Wallpaper Manager");

    // Test monitor detection
    let monitors = services::hyprctl::get_monitors()?;
    println!("Detected {} monitors:", monitors.len());
    for mon in &monitors {
        let (lw, lh) = mon.logical_size();
        println!("  {} @ {}x{} (logical: {:.0}x{:.0}, scale: {})",
            mon.name, mon.width, mon.height, lw, lh, mon.scale);
    }

    Ok(())
}
```
  </action>
  <verify>
cd vulcan-wallpaper-manager && cargo build && cargo run
  </verify>
  <done>Running `cargo run` detects and prints all connected monitors with correct dimensions</done>
</task>

</tasks>

<verification>
1. `cd vulcan-wallpaper-manager && cargo build` succeeds
2. `cargo run` outputs monitor list with names, resolutions, and logical sizes
3. Monitor struct correctly deserializes hyprctl JSON (test with `hyprctl monitors -j`)
4. Profile struct can serialize to TOML and deserialize back
</verification>

<success_criteria>
- vulcan-wallpaper-manager/ directory exists with proper Cargo project structure
- All dependencies from research (gtk4, libadwaita, relm4, image, serde, toml) are in Cargo.toml
- Monitor, Wallpaper, WallpaperProfile types defined with serde derives
- hyprctl service can query monitors and parse JSON response
- Project compiles and runs without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-vulcanos-wallpaper-manager/05-01-SUMMARY.md`
</output>
