---
phase: 05-vulcanos-wallpaper-manager
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - vulcan-wallpaper-manager/src/components/wallpaper_picker.rs
  - vulcan-wallpaper-manager/src/components/mod.rs
  - vulcan-wallpaper-manager/src/services/thumbnail.rs
  - vulcan-wallpaper-manager/src/services/mod.rs
autonomous: true

must_haves:
  truths:
    - "User can browse wallpaper directory and see thumbnails"
    - "Selecting a wallpaper emits selection event"
    - "Thumbnails are cached in ~/.cache/vulcan-wallpaper/"
  artifacts:
    - path: "vulcan-wallpaper-manager/src/components/wallpaper_picker.rs"
      provides: "Grid view of wallpaper thumbnails"
      contains: "GridView"
    - path: "vulcan-wallpaper-manager/src/services/thumbnail.rs"
      provides: "Thumbnail generation and caching"
      exports: ["generate_thumbnail", "get_cached_thumbnail"]
  key_links:
    - from: "vulcan-wallpaper-manager/src/services/thumbnail.rs"
      to: "image crate"
      via: "ImageReader::open"
      pattern: "ImageReader"
---

<objective>
Create the wallpaper picker component with thumbnail grid and file browsing capabilities.

Purpose: Allow users to visually browse and select wallpapers with cached thumbnail previews.
Output: Scrollable grid of wallpaper thumbnails with selection handling and lazy loading.
</objective>

<execution_context>
@/home/evan/.claude/get-shit-done/workflows/execute-plan.md
@/home/evan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-vulcanos-wallpaper-manager/05-RESEARCH.md
@.planning/phases/05-vulcanos-wallpaper-manager/05-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create thumbnail generation service</name>
  <files>
    vulcan-wallpaper-manager/src/services/thumbnail.rs
    vulcan-wallpaper-manager/src/services/mod.rs
  </files>
  <action>
Create thumbnail service using the image crate:

services/thumbnail.rs:
```rust
use std::path::{Path, PathBuf};
use std::fs;
use image::ImageReader;
use anyhow::{Result, Context};

const THUMBNAIL_SIZE: u32 = 200;

/// Get the cache directory for thumbnails
pub fn cache_dir() -> PathBuf {
    dirs::cache_dir()
        .unwrap_or_else(|| PathBuf::from("/tmp"))
        .join("vulcan-wallpaper")
}

/// Generate a unique cache filename for a source image
fn cache_path(source: &Path) -> PathBuf {
    use std::collections::hash_map::DefaultHasher;
    use std::hash::{Hash, Hasher};

    let mut hasher = DefaultHasher::new();
    source.to_string_lossy().hash(&mut hasher);

    // Include file modification time in hash
    if let Ok(metadata) = fs::metadata(source) {
        if let Ok(modified) = metadata.modified() {
            modified.hash(&mut hasher);
        }
    }

    let hash = hasher.finish();
    cache_dir().join(format!("{:016x}.png", hash))
}

/// Get cached thumbnail path if it exists
pub fn get_cached_thumbnail(source: &Path) -> Option<PathBuf> {
    let cache = cache_path(source);
    if cache.exists() {
        Some(cache)
    } else {
        None
    }
}

/// Generate thumbnail for an image, caching the result
pub fn generate_thumbnail(source: &Path) -> Result<PathBuf> {
    let cache = cache_path(source);

    // Return cached version if exists
    if cache.exists() {
        return Ok(cache);
    }

    // Ensure cache directory exists
    let cache_parent = cache.parent().unwrap();
    fs::create_dir_all(cache_parent)
        .context("Failed to create cache directory")?;

    // Load and resize image
    let img = ImageReader::open(source)
        .context("Failed to open image")?
        .decode()
        .context("Failed to decode image")?;

    // Calculate thumbnail size maintaining aspect ratio
    let (width, height) = img.dimensions();
    let ratio = (THUMBNAIL_SIZE as f32 / width as f32)
        .min(THUMBNAIL_SIZE as f32 / height as f32);
    let thumb_width = (width as f32 * ratio) as u32;
    let thumb_height = (height as f32 * ratio) as u32;

    // Resize using Lanczos3 for quality
    let thumbnail = img.resize(
        thumb_width,
        thumb_height,
        image::imageops::FilterType::Lanczos3,
    );

    // Save thumbnail
    thumbnail.save(&cache)
        .context("Failed to save thumbnail")?;

    Ok(cache)
}

/// Scan a directory for image files
pub fn scan_wallpaper_directory(dir: &Path) -> Result<Vec<PathBuf>> {
    let mut images = Vec::new();

    if !dir.exists() {
        return Ok(images);
    }

    for entry in fs::read_dir(dir).context("Failed to read directory")? {
        let entry = entry?;
        let path = entry.path();

        if path.is_file() {
            if let Some(ext) = path.extension() {
                let ext = ext.to_string_lossy().to_lowercase();
                if matches!(ext.as_str(), "png" | "jpg" | "jpeg" | "webp" | "bmp") {
                    images.push(path);
                }
            }
        }
    }

    images.sort();
    Ok(images)
}

/// Get the default wallpaper directory
pub fn default_wallpaper_dir() -> PathBuf {
    dirs::picture_dir()
        .unwrap_or_else(|| dirs::home_dir().unwrap_or_default().join("Pictures"))
        .join("Wallpapers")
}
```

Update services/mod.rs:
```rust
pub mod hyprctl;
pub mod thumbnail;
```
  </action>
  <verify>
cd vulcan-wallpaper-manager && cargo check
  </verify>
  <done>Thumbnail service compiles with image crate integration</done>
</task>

<task type="auto">
  <name>Task 2: Create wallpaper picker component</name>
  <files>
    vulcan-wallpaper-manager/src/components/wallpaper_picker.rs
    vulcan-wallpaper-manager/src/components/mod.rs
  </files>
  <action>
Create wallpaper picker with scrollable grid:

components/wallpaper_picker.rs:
```rust
use gtk::prelude::*;
use gtk::glib;
use relm4::prelude::*;
use std::path::PathBuf;

use crate::services::thumbnail;

const THUMBNAIL_SIZE: i32 = 150;
const GRID_COLUMNS: u32 = 4;

#[derive(Debug)]
pub enum WallpaperPickerInput {
    LoadDirectory(PathBuf),
    Refresh,
}

#[derive(Debug)]
pub enum WallpaperPickerOutput {
    Selected(PathBuf),
}

pub struct WallpaperPickerModel {
    wallpapers: Vec<PathBuf>,
    current_dir: PathBuf,
}

#[relm4::component(pub)]
impl SimpleComponent for WallpaperPickerModel {
    type Init = PathBuf;
    type Input = WallpaperPickerInput;
    type Output = WallpaperPickerOutput;

    view! {
        gtk::ScrolledWindow {
            set_hscrollbar_policy: gtk::PolicyType::Never,
            set_vscrollbar_policy: gtk::PolicyType::Automatic,
            set_min_content_height: 300,
            set_hexpand: true,
            set_vexpand: true,

            gtk::FlowBox {
                set_homogeneous: true,
                set_max_children_per_line: GRID_COLUMNS,
                set_min_children_per_line: 2,
                set_selection_mode: gtk::SelectionMode::Single,
                set_row_spacing: 8,
                set_column_spacing: 8,

                connect_child_activated[sender] => move |_, child| {
                    if let Some(path) = get_wallpaper_path(child) {
                        let _ = sender.output(WallpaperPickerOutput::Selected(path));
                    }
                },

                #[iterate]
                append: model.wallpapers.iter().map(|path| {
                    create_wallpaper_item(path)
                }).collect::<Vec<_>>().as_slice(),
            },
        }
    }

    fn init(
        directory: Self::Init,
        _root: Self::Root,
        sender: ComponentSender<Self>,
    ) -> ComponentParts<Self> {
        let wallpapers = thumbnail::scan_wallpaper_directory(&directory)
            .unwrap_or_default();

        let model = WallpaperPickerModel {
            wallpapers,
            current_dir: directory,
        };

        let widgets = view_output!();

        ComponentParts { model, widgets }
    }

    fn update(&mut self, msg: Self::Input, _sender: ComponentSender<Self>) {
        match msg {
            WallpaperPickerInput::LoadDirectory(dir) => {
                self.current_dir = dir.clone();
                self.wallpapers = thumbnail::scan_wallpaper_directory(&dir)
                    .unwrap_or_default();
            }
            WallpaperPickerInput::Refresh => {
                self.wallpapers = thumbnail::scan_wallpaper_directory(&self.current_dir)
                    .unwrap_or_default();
            }
        }
    }
}

/// Create a wallpaper thumbnail item for the grid
fn create_wallpaper_item(path: &PathBuf) -> gtk::FlowBoxChild {
    let child = gtk::FlowBoxChild::new();

    let vbox = gtk::Box::builder()
        .orientation(gtk::Orientation::Vertical)
        .spacing(4)
        .build();

    // Create frame for thumbnail
    let frame = gtk::Frame::builder()
        .width_request(THUMBNAIL_SIZE)
        .height_request(THUMBNAIL_SIZE)
        .build();

    // Try to load thumbnail
    let picture = if let Some(thumb) = thumbnail::get_cached_thumbnail(path) {
        gtk::Picture::for_filename(&thumb)
    } else {
        // Generate thumbnail in background (for now, synchronous)
        match thumbnail::generate_thumbnail(path) {
            Ok(thumb) => gtk::Picture::for_filename(&thumb),
            Err(_) => {
                // Fallback to icon
                let icon = gtk::Image::from_icon_name("image-missing");
                icon.set_pixel_size(THUMBNAIL_SIZE);
                frame.set_child(Some(&icon));

                // Still create a label
                let name = path.file_stem()
                    .and_then(|s| s.to_str())
                    .unwrap_or("?");
                let label = gtk::Label::builder()
                    .label(name)
                    .ellipsize(gtk::pango::EllipsizeMode::End)
                    .max_width_chars(15)
                    .build();

                vbox.append(&frame);
                vbox.append(&label);
                child.set_child(Some(&vbox));

                // Store path for later retrieval
                child.set_widget_name(&path.to_string_lossy());

                return child;
            }
        }
    };

    picture.set_content_fit(gtk::ContentFit::Cover);
    frame.set_child(Some(&picture));

    // Filename label
    let name = path.file_stem()
        .and_then(|s| s.to_str())
        .unwrap_or("?");
    let label = gtk::Label::builder()
        .label(name)
        .ellipsize(gtk::pango::EllipsizeMode::End)
        .max_width_chars(15)
        .build();

    vbox.append(&frame);
    vbox.append(&label);
    child.set_child(Some(&vbox));

    // Store path for later retrieval
    child.set_widget_name(&path.to_string_lossy());

    child
}

/// Extract wallpaper path from FlowBoxChild widget name
fn get_wallpaper_path(child: &gtk::FlowBoxChild) -> Option<PathBuf> {
    let name = child.widget_name();
    if !name.is_empty() {
        Some(PathBuf::from(name.as_str()))
    } else {
        None
    }
}
```

Update components/mod.rs:
```rust
pub mod monitor_layout;
pub mod wallpaper_picker;
```
  </action>
  <verify>
cd vulcan-wallpaper-manager && cargo check
  </verify>
  <done>Wallpaper picker component compiles with FlowBox grid</done>
</task>

<task type="auto">
  <name>Task 3: Test thumbnail generation and caching</name>
  <files>
    vulcan-wallpaper-manager/src/main.rs
  </files>
  <action>
Add a simple test to verify thumbnail generation works:

Create a test by temporarily modifying main.rs (or create a test module):

```rust
// Add this test function to services/thumbnail.rs
#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;

    #[test]
    fn test_scan_wallpaper_directory() {
        let dir = default_wallpaper_dir();
        let result = scan_wallpaper_directory(&dir);
        assert!(result.is_ok());
        // Just verify it doesn't crash - may or may not find files
    }

    #[test]
    fn test_cache_dir_creation() {
        let cache = cache_dir();
        fs::create_dir_all(&cache).unwrap();
        assert!(cache.exists());
    }
}
```

Run the tests:
```bash
cd vulcan-wallpaper-manager && cargo test
```

Verify the cache directory is created at `~/.cache/vulcan-wallpaper/`
  </action>
  <verify>
cd vulcan-wallpaper-manager && cargo test
  </verify>
  <done>Thumbnail service tests pass, cache directory is created</done>
</task>

</tasks>

<verification>
1. `cargo test` passes for thumbnail module
2. Thumbnail generation creates files in `~/.cache/vulcan-wallpaper/`
3. Scanning `~/Pictures/Wallpapers/` finds image files
4. WallpaperPickerModel compiles and can be used as a component
5. FlowBox displays thumbnail grid when integrated into app
</verification>

<success_criteria>
- Thumbnail service generates 200x200 thumbnails maintaining aspect ratio
- Thumbnails are cached based on source file path + modification time
- Wallpaper picker shows scrollable grid of thumbnails
- Clicking a wallpaper emits WallpaperPickerOutput::Selected
- Component handles missing images gracefully (shows placeholder)
</success_criteria>

<output>
After completion, create `.planning/phases/05-vulcanos-wallpaper-manager/05-03-SUMMARY.md`
</output>
