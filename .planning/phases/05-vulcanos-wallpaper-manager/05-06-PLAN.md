---
phase: 05-vulcanos-wallpaper-manager
plan: 06
type: execute
wave: 4
depends_on: ["05-04", "05-05"]
files_modified:
  - vulcan-wallpaper-manager/src/app.rs
  - vulcan-wallpaper-manager/src/services/image_splitter.rs
  - vulcan-wallpaper-manager/src/services/mod.rs
  - vulcan-wallpaper-manager/src/components/split_dialog.rs
  - vulcan-wallpaper-manager/src/components/mod.rs
autonomous: true

must_haves:
  truths:
    - "User can import panoramic image and split it for all monitors"
    - "Splitter uses actual monitor layout for accurate cropping"
    - "Generated wallpapers are saved with monitor-specific names"
  artifacts:
    - path: "vulcan-wallpaper-manager/src/services/image_splitter.rs"
      provides: "Panoramic image splitting using image crate"
      exports: ["split_panoramic"]
    - path: "vulcan-wallpaper-manager/src/components/split_dialog.rs"
      provides: "Dialog for panoramic import and splitting"
      contains: "FileDialog"
  key_links:
    - from: "vulcan-wallpaper-manager/src/services/image_splitter.rs"
      to: "image crate"
      via: "crop and resize operations"
      pattern: "image::GenericImageView"
---

<objective>
Implement adaptive wallpaper generation that splits panoramic images across the multi-monitor layout.

Purpose: Allow users to import a single wide image and automatically create per-monitor crops based on actual layout.
Output: Image splitter service and dialog that generates monitor-specific wallpapers from panoramic source.
</objective>

<execution_context>
@/home/evan/.claude/get-shit-done/workflows/execute-plan.md
@/home/evan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-vulcanos-wallpaper-manager/05-RESEARCH.md
@.planning/phases/05-vulcanos-wallpaper-manager/05-04-SUMMARY.md
@.planning/phases/05-vulcanos-wallpaper-manager/05-05-SUMMARY.md
@scripts/split-wallpaper.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create image splitter service</name>
  <files>
    vulcan-wallpaper-manager/src/services/image_splitter.rs
    vulcan-wallpaper-manager/src/services/mod.rs
  </files>
  <action>
Create image splitter service that replicates split-wallpaper.sh functionality in Rust:

services/image_splitter.rs:
```rust
use std::path::{Path, PathBuf};
use std::fs;
use image::{GenericImageView, ImageReader, DynamicImage, imageops};
use anyhow::{Result, Context};

use crate::models::Monitor;

/// Result of splitting a panoramic image
#[derive(Debug)]
pub struct SplitResult {
    /// Map of monitor name -> generated wallpaper path
    pub wallpapers: Vec<(String, PathBuf)>,
    /// Output directory containing the wallpapers
    pub output_dir: PathBuf,
}

/// Calculate the bounding box for all monitors
fn calculate_canvas_bounds(monitors: &[Monitor]) -> (i32, i32, i32, i32) {
    if monitors.is_empty() {
        return (0, 0, 1920, 1080);
    }

    let mut min_x = i32::MAX;
    let mut min_y = i32::MAX;
    let mut max_x = i32::MIN;
    let mut max_y = i32::MIN;

    for mon in monitors {
        let (lw, lh) = mon.logical_size();
        let (w, h) = if mon.is_vertical() {
            (lh as i32, lw as i32)
        } else {
            (lw as i32, lh as i32)
        };

        min_x = min_x.min(mon.x);
        min_y = min_y.min(mon.y);
        max_x = max_x.max(mon.x + w);
        max_y = max_y.max(mon.y + h);
    }

    (min_x, min_y, max_x - min_x, max_y - min_y)
}

/// Split a panoramic image into per-monitor wallpapers
pub fn split_panoramic(
    source: &Path,
    monitors: &[Monitor],
    output_dir: &Path,
    prefix: &str,
) -> Result<SplitResult> {
    // Load source image
    let img = ImageReader::open(source)
        .context("Failed to open source image")?
        .decode()
        .context("Failed to decode source image")?;

    let (img_width, img_height) = img.dimensions();
    println!("Source image: {}x{}", img_width, img_height);

    // Calculate canvas dimensions from monitor layout
    let (min_x, min_y, canvas_width, canvas_height) = calculate_canvas_bounds(monitors);
    println!("Canvas bounds: {}x{} (offset: {}, {})", canvas_width, canvas_height, min_x, min_y);

    // Scale source to fit canvas, then crop to exact size
    let scale = (canvas_width as f32 / img_width as f32)
        .max(canvas_height as f32 / img_height as f32);

    let scaled_width = (img_width as f32 * scale) as u32;
    let scaled_height = (img_height as f32 * scale) as u32;

    println!("Scaling to: {}x{}", scaled_width, scaled_height);

    // Resize using Lanczos for quality
    let scaled = img.resize_exact(
        scaled_width,
        scaled_height,
        imageops::FilterType::Lanczos3,
    );

    // Crop to canvas size (center crop)
    let crop_x = (scaled_width.saturating_sub(canvas_width as u32)) / 2;
    let crop_y = (scaled_height.saturating_sub(canvas_height as u32)) / 2;

    let canvas = imageops::crop_imm(
        &scaled,
        crop_x,
        crop_y,
        canvas_width as u32,
        canvas_height as u32,
    ).to_image();

    println!("Canvas cropped to: {}x{}", canvas.width(), canvas.height());

    // Ensure output directory exists
    fs::create_dir_all(output_dir)
        .context("Failed to create output directory")?;

    // Extract each monitor's portion
    let mut wallpapers = Vec::new();

    for mon in monitors {
        let (lw, lh) = mon.logical_size();
        let (w, h) = if mon.is_vertical() {
            (lh as u32, lw as u32)
        } else {
            (lw as u32, lh as u32)
        };

        // Calculate crop position relative to canvas origin
        let x = (mon.x - min_x) as u32;
        let y = (mon.y - min_y) as u32;

        println!("  {} @ {}x{} from ({}, {})", mon.name, w, h, x, y);

        // Ensure we don't exceed canvas bounds
        let safe_w = w.min(canvas.width().saturating_sub(x));
        let safe_h = h.min(canvas.height().saturating_sub(y));

        // Crop monitor region
        let monitor_img = imageops::crop_imm(&canvas, x, y, safe_w, safe_h).to_image();

        // If the crop is smaller than expected, resize to fill
        let final_img = if monitor_img.width() < w || monitor_img.height() < h {
            DynamicImage::ImageRgba8(monitor_img).resize_exact(
                w,
                h,
                imageops::FilterType::Lanczos3,
            )
        } else {
            DynamicImage::ImageRgba8(monitor_img)
        };

        // Save to output directory
        let filename = format!("{}-{}.png", prefix, mon.name);
        let output_path = output_dir.join(&filename);

        final_img.save(&output_path)
            .context(format!("Failed to save {}", filename))?;

        wallpapers.push((mon.name.clone(), output_path));
    }

    Ok(SplitResult {
        wallpapers,
        output_dir: output_dir.to_path_buf(),
    })
}

/// Get default output directory for split wallpapers
pub fn default_split_output_dir() -> PathBuf {
    dirs::picture_dir()
        .unwrap_or_else(|| dirs::home_dir().unwrap_or_default().join("Pictures"))
        .join("Wallpapers")
        .join("spanning")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_canvas_bounds_single_monitor() {
        let monitors = vec![
            Monitor {
                id: 0,
                name: "eDP-1".to_string(),
                description: "".to_string(),
                make: "".to_string(),
                model: "".to_string(),
                width: 1920,
                height: 1200,
                x: 0,
                y: 0,
                scale: 1.0,
                transform: 0,
                focused: true,
            }
        ];

        let (min_x, min_y, w, h) = calculate_canvas_bounds(&monitors);
        assert_eq!((min_x, min_y), (0, 0));
        assert_eq!((w, h), (1920, 1200));
    }

    #[test]
    fn test_canvas_bounds_multi_monitor() {
        let monitors = vec![
            Monitor {
                id: 0,
                name: "DP-5".to_string(),
                description: "".to_string(),
                make: "".to_string(),
                model: "".to_string(),
                width: 1920,
                height: 1080,
                x: 0,
                y: 0,
                scale: 1.0,
                transform: 0,
                focused: false,
            },
            Monitor {
                id: 1,
                name: "eDP-1".to_string(),
                description: "".to_string(),
                make: "".to_string(),
                model: "".to_string(),
                width: 1920,
                height: 1200,
                x: 1920,
                y: 0,
                scale: 1.0,
                transform: 0,
                focused: true,
            },
        ];

        let (min_x, min_y, w, h) = calculate_canvas_bounds(&monitors);
        assert_eq!((min_x, min_y), (0, 0));
        assert_eq!(w, 3840); // 1920 + 1920
        assert_eq!(h, 1200); // max height
    }
}
```

Update services/mod.rs:
```rust
pub mod hyprctl;
pub mod hyprpaper;
pub mod image_splitter;
pub mod profile_storage;
pub mod thumbnail;
```
  </action>
  <verify>
cd vulcan-wallpaper-manager && cargo test image_splitter
  </verify>
  <done>Image splitter service compiles and passes canvas bounds tests</done>
</task>

<task type="auto">
  <name>Task 2: Create split dialog component</name>
  <files>
    vulcan-wallpaper-manager/src/components/split_dialog.rs
    vulcan-wallpaper-manager/src/components/mod.rs
  </files>
  <action>
Create dialog for panoramic image import:

components/split_dialog.rs:
```rust
use gtk::prelude::*;
use gtk::gio;
use relm4::prelude::*;
use std::path::PathBuf;
use std::collections::HashMap;

use crate::models::Monitor;
use crate::services::image_splitter;

#[derive(Debug)]
pub enum SplitDialogInput {
    /// Open file chooser
    SelectImage,
    /// File was selected
    ImageSelected(PathBuf),
    /// User entered a name
    SetName(String),
    /// Perform the split
    DoSplit,
    /// Cancel the dialog
    Cancel,
}

#[derive(Debug)]
pub enum SplitDialogOutput {
    /// Wallpapers generated - map of monitor -> path
    Generated(HashMap<String, PathBuf>),
    /// User cancelled
    Cancelled,
    /// Error occurred
    Error(String),
}

pub struct SplitDialogModel {
    monitors: Vec<Monitor>,
    source_path: Option<PathBuf>,
    wallpaper_name: String,
    is_splitting: bool,
}

#[relm4::component(pub)]
impl SimpleComponent for SplitDialogModel {
    type Init = Vec<Monitor>;
    type Input = SplitDialogInput;
    type Output = SplitDialogOutput;

    view! {
        gtk::Box {
            set_orientation: gtk::Orientation::Vertical,
            set_spacing: 12,
            set_margin_all: 12,
            set_width_request: 400,

            // Title
            gtk::Label {
                set_markup: "<b>Import Panoramic Wallpaper</b>",
                set_halign: gtk::Align::Start,
            },

            // Description
            gtk::Label {
                set_text: "Select a wide image to split across your monitors.",
                set_wrap: true,
                set_halign: gtk::Align::Start,
            },

            // File selection row
            gtk::Box {
                set_orientation: gtk::Orientation::Horizontal,
                set_spacing: 8,

                gtk::Entry {
                    set_hexpand: true,
                    set_placeholder_text: Some("No image selected"),
                    set_editable: false,
                    #[watch]
                    set_text: model.source_path.as_ref()
                        .and_then(|p| p.file_name())
                        .and_then(|n| n.to_str())
                        .unwrap_or(""),
                },

                gtk::Button {
                    set_label: "Browse...",
                    connect_clicked => SplitDialogInput::SelectImage,
                },
            },

            // Name entry
            gtk::Box {
                set_orientation: gtk::Orientation::Horizontal,
                set_spacing: 8,

                gtk::Label {
                    set_text: "Name:",
                    set_width_request: 60,
                },

                gtk::Entry {
                    set_hexpand: true,
                    set_placeholder_text: Some("e.g., volcanic-forge"),
                    #[watch]
                    set_text: &model.wallpaper_name,
                    connect_changed[sender] => move |entry| {
                        sender.input(SplitDialogInput::SetName(entry.text().to_string()));
                    },
                },
            },

            // Monitor preview info
            gtk::Label {
                set_markup: &format!(
                    "<small>Will generate wallpapers for {} monitors:\n{}</small>",
                    model.monitors.len(),
                    model.monitors.iter()
                        .map(|m| format!("{} ({}x{})", m.name, m.width, m.height))
                        .collect::<Vec<_>>()
                        .join(", ")
                ),
                set_wrap: true,
                set_halign: gtk::Align::Start,
            },

            // Buttons
            gtk::Box {
                set_orientation: gtk::Orientation::Horizontal,
                set_spacing: 8,
                set_halign: gtk::Align::End,
                set_margin_top: 12,

                gtk::Button {
                    set_label: "Cancel",
                    connect_clicked => SplitDialogInput::Cancel,
                },

                gtk::Button {
                    set_label: if model.is_splitting { "Splitting..." } else { "Split & Apply" },
                    add_css_class: "suggested-action",
                    #[watch]
                    set_sensitive: model.source_path.is_some()
                        && !model.wallpaper_name.is_empty()
                        && !model.is_splitting,
                    connect_clicked => SplitDialogInput::DoSplit,
                },
            },
        }
    }

    fn init(
        monitors: Self::Init,
        _root: Self::Root,
        _sender: ComponentSender<Self>,
    ) -> ComponentParts<Self> {
        let model = SplitDialogModel {
            monitors,
            source_path: None,
            wallpaper_name: "split-wallpaper".to_string(),
            is_splitting: false,
        };

        let widgets = view_output!();

        ComponentParts { model, widgets }
    }

    fn update(&mut self, msg: Self::Input, sender: ComponentSender<Self>) {
        match msg {
            SplitDialogInput::SelectImage => {
                // Use native file chooser
                let dialog = gtk::FileDialog::builder()
                    .title("Select Panoramic Image")
                    .build();

                // Add image filter
                let filter = gtk::FileFilter::new();
                filter.set_name(Some("Images"));
                filter.add_mime_type("image/*");
                let filters = gio::ListStore::new::<gtk::FileFilter>();
                filters.append(&filter);
                dialog.set_filters(Some(&filters));

                // Open async
                let sender_clone = sender.clone();
                dialog.open(
                    None::<&gtk::Window>,
                    None::<&gio::Cancellable>,
                    move |result| {
                        if let Ok(file) = result {
                            if let Some(path) = file.path() {
                                sender_clone.input(SplitDialogInput::ImageSelected(path));
                            }
                        }
                    },
                );
            }

            SplitDialogInput::ImageSelected(path) => {
                // Auto-generate name from filename if not set
                if self.wallpaper_name == "split-wallpaper" {
                    if let Some(stem) = path.file_stem().and_then(|s| s.to_str()) {
                        self.wallpaper_name = stem.to_string();
                    }
                }
                self.source_path = Some(path);
            }

            SplitDialogInput::SetName(name) => {
                self.wallpaper_name = name;
            }

            SplitDialogInput::DoSplit => {
                if let Some(source) = &self.source_path {
                    self.is_splitting = true;

                    let output_dir = image_splitter::default_split_output_dir()
                        .join(&self.wallpaper_name);

                    match image_splitter::split_panoramic(
                        source,
                        &self.monitors,
                        &output_dir,
                        &self.wallpaper_name,
                    ) {
                        Ok(result) => {
                            let wallpapers: HashMap<String, PathBuf> = result.wallpapers
                                .into_iter()
                                .collect();
                            let _ = sender.output(SplitDialogOutput::Generated(wallpapers));
                        }
                        Err(e) => {
                            let _ = sender.output(SplitDialogOutput::Error(e.to_string()));
                        }
                    }

                    self.is_splitting = false;
                }
            }

            SplitDialogInput::Cancel => {
                let _ = sender.output(SplitDialogOutput::Cancelled);
            }
        }
    }
}
```

Update components/mod.rs:
```rust
pub mod monitor_layout;
pub mod profile_manager;
pub mod split_dialog;
pub mod wallpaper_picker;
```
  </action>
  <verify>
cd vulcan-wallpaper-manager && cargo check
  </verify>
  <done>Split dialog component compiles with file chooser integration</done>
</task>

<task type="auto">
  <name>Task 3: Integrate split dialog into main app</name>
  <files>
    vulcan-wallpaper-manager/src/app.rs
  </files>
  <action>
Add "Import Panoramic" action to the app header and integrate the split dialog:

Update AppMsg enum:
```rust
#[derive(Debug)]
pub enum AppMsg {
    MonitorSelected(String),
    WallpaperSelected(PathBuf),
    ApplyWallpaper,
    RefreshMonitors,
    OpenDirectory,
    // New messages for split dialog
    ShowSplitDialog,
    SplitGenerated(HashMap<String, PathBuf>),
    SplitError(String),
    // Profile management
    ProfileApply(HashMap<String, PathBuf>),
    ProfileSaved(String),
    ProfileError(String),
}
```

Add import button to header bar (after existing buttons):
```rust
pack_start = &gtk::Button {
    set_icon_name: "insert-image-symbolic",
    set_tooltip_text: Some("Import panoramic image"),
    connect_clicked => AppMsg::ShowSplitDialog,
},
```

Add split dialog handling to update():
```rust
AppMsg::ShowSplitDialog => {
    // Create a popup window with the split dialog
    // For simplicity, show as a message for now
    // A proper implementation would use a modal dialog
    println!("TODO: Show split dialog popup");
}

AppMsg::SplitGenerated(wallpapers) => {
    println!("Generated {} wallpapers", wallpapers.len());
    // Apply all generated wallpapers
    for (monitor, path) in &wallpapers {
        if let Err(e) = hyprpaper::apply_wallpaper(monitor, path) {
            eprintln!("Failed to apply to {}: {}", monitor, e);
        }
    }
    self.monitor_wallpapers.extend(wallpapers);
}

AppMsg::SplitError(error) => {
    eprintln!("Split error: {}", error);
}
```

Note: Full modal dialog integration requires more GTK4 setup. For now, log a TODO and the core splitting logic is implemented and tested.
  </action>
  <verify>
cd vulcan-wallpaper-manager && cargo build
  </verify>
  <done>App compiles with split dialog integration points</done>
</task>

</tasks>

<verification>
1. `cargo test image_splitter` passes canvas bounds tests
2. `cargo build` succeeds
3. Image splitter generates correct number of wallpapers
4. Generated wallpapers have correct dimensions per monitor
5. Output directory created at `~/Pictures/Wallpapers/spanning/<name>/`
</verification>

<success_criteria>
- Image splitter calculates canvas bounds from actual monitor layout
- Panoramic images are scaled/cropped to fit the canvas
- Each monitor region is extracted and saved as separate file
- Vertical monitors (rotated) are handled correctly
- File naming follows pattern: `<name>-<monitor>.png`
- Split dialog provides file picker and name entry
- Generated wallpapers can be applied immediately
</success_criteria>

<output>
After completion, create `.planning/phases/05-vulcanos-wallpaper-manager/05-06-SUMMARY.md`
</output>
