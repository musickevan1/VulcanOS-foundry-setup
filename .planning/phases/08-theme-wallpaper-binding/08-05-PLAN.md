---
phase: 08-theme-wallpaper-binding
plan: 05
type: execute
wave: 3
depends_on: ["08-02"]
files_modified:
  - vulcan-appearance-manager/src/components/profile_card.rs
  - vulcan-appearance-manager/src/components/profile_view.rs
  - vulcan-appearance-manager/src/components/mod.rs
autonomous: true

must_haves:
  truths:
    - "Profiles tab shows grid of profile cards"
    - "Profile card displays theme colors and wallpaper thumbnail"
    - "User can load a profile by clicking it"
    - "User can delete a profile via trash button"
    - "User can save current state as new profile"
  artifacts:
    - path: "vulcan-appearance-manager/src/components/profile_card.rs"
      provides: "ProfileItem factory component for FlowBox"
      exports: ["ProfileItem", "ProfileCardOutput"]
    - path: "vulcan-appearance-manager/src/components/profile_view.rs"
      provides: "ProfileView container for profiles tab"
      exports: ["ProfileViewModel", "ProfileViewMsg", "ProfileViewOutput"]
    - path: "vulcan-appearance-manager/src/components/mod.rs"
      provides: "Module exports for profile components"
      contains: "pub mod profile_card"
  key_links:
    - from: "vulcan-appearance-manager/src/components/profile_view.rs"
      to: "vulcan-appearance-manager/src/services/profile_storage.rs"
      via: "loads/saves unified profiles"
      pattern: "load_unified_profile\\|save_unified_profile"
    - from: "vulcan-appearance-manager/src/components/profile_card.rs"
      to: "vulcan-appearance-manager/src/models/binding.rs"
      via: "displays UnifiedProfile data"
      pattern: "UnifiedProfile"
---

<objective>
Create the Profiles tab UI with profile cards for save/load/delete operations

Purpose: Enable users to save coordinated appearance settings (theme + wallpapers + binding mode) as named profiles and quickly switch between them. This is the third tab in the unified app.

Output: New profile_card.rs and profile_view.rs components implementing the Profiles tab with FlowBox of profile cards
</objective>

<execution_context>
@/home/evan/.claude/get-shit-done/workflows/execute-plan.md
@/home/evan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-theme-wallpaper-binding/08-CONTEXT.md
@.planning/phases/08-theme-wallpaper-binding/08-RESEARCH.md

@vulcan-appearance-manager/src/components/theme_card.rs (reference for factory pattern)
@vulcan-appearance-manager/src/components/theme_browser.rs (reference for FlowBox usage)
@vulcan-appearance-manager/src/services/profile_storage.rs
@vulcan-appearance-manager/src/models/binding.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ProfileItem factory component</name>
  <files>
    vulcan-appearance-manager/src/components/profile_card.rs
    vulcan-appearance-manager/src/components/mod.rs
  </files>
  <action>
Create profile_card.rs with ProfileItem for displaying unified profiles in a FlowBox:

```rust
use gtk::prelude::*;
use gtk::gio;
use relm4::prelude::*;
use relm4::factory::{FactoryComponent, DynamicIndex, FactorySender};

use crate::models::{UnifiedProfile, BindingMode};
use crate::services::theme_storage;

/// Output messages from ProfileCard
#[derive(Debug)]
pub enum ProfileCardOutput {
    Load(String),    // profile name to load
    Delete(String),  // profile name to delete
}

/// Factory item for profile display in FlowBox
#[derive(Debug)]
pub struct ProfileItem {
    pub profile: UnifiedProfile,
    pub is_active: bool,
}

#[relm4::factory(pub)]
impl FactoryComponent for ProfileItem {
    type Init = (UnifiedProfile, bool);
    type Input = ();
    type Output = ProfileCardOutput;
    type CommandOutput = ();
    type ParentWidget = gtk::FlowBox;

    view! {
        gtk::Box {
            set_orientation: gtk::Orientation::Vertical,
            set_spacing: 8,
            set_width_request: 200,
            set_margin_all: 8,
            add_css_class: "profile-card",

            // Preview area: theme colors (left) + wallpaper (right)
            gtk::Box {
                set_orientation: gtk::Orientation::Horizontal,
                set_spacing: 4,
                set_height_request: 100,

                // Theme color preview (if theme bound)
                #[name = "theme_preview"]
                gtk::Frame {
                    set_hexpand: true,

                    #[name = "color_box"]
                    gtk::Box {
                        set_orientation: gtk::Orientation::Vertical,
                        set_spacing: 2,
                        set_margin_all: 4,
                    },
                },

                // Wallpaper preview
                gtk::Frame {
                    set_hexpand: true,

                    #[name = "wallpaper_picture"]
                    gtk::Picture {
                        set_content_fit: gtk::ContentFit::Cover,
                        set_can_shrink: true,
                    },
                },
            },

            // Profile name
            gtk::Label {
                #[watch]
                set_label: &self.profile.name,
                add_css_class: "profile-name",
                set_halign: gtk::Align::Start,
                set_ellipsize: gtk::pango::EllipsizeMode::End,
            },

            // Info line: theme name + binding mode
            gtk::Label {
                #[watch]
                set_label: &format!(
                    "{} â€¢ {}",
                    self.profile.theme_id.as_deref().unwrap_or("No theme"),
                    self.profile.binding_mode.display_name()
                ),
                add_css_class: "dim-label",
                set_halign: gtk::Align::Start,
                set_ellipsize: gtk::pango::EllipsizeMode::End,
            },

            // Action buttons row
            gtk::Box {
                set_orientation: gtk::Orientation::Horizontal,
                set_spacing: 4,

                gtk::Button {
                    set_label: "Load",
                    set_hexpand: true,
                    #[watch]
                    add_css_class[self.is_active]: "suggested-action",
                    connect_clicked[sender, name = self.profile.name.clone()] => move |_| {
                        sender.output(ProfileCardOutput::Load(name.clone())).ok();
                    },
                },

                gtk::Button {
                    set_icon_name: "user-trash-symbolic",
                    set_tooltip_text: Some("Delete profile"),
                    connect_clicked[sender, name = self.profile.name.clone()] => move |_| {
                        sender.output(ProfileCardOutput::Delete(name.clone())).ok();
                    },
                },
            },

            // Active badge
            gtk::Label {
                #[watch]
                set_visible: self.is_active,
                set_label: "Active",
                add_css_class: "current-badge",
                set_halign: gtk::Align::Center,
            },
        }
    }

    fn init_model(init: Self::Init, _index: &DynamicIndex, _sender: FactorySender<Self>) -> Self {
        ProfileItem {
            profile: init.0,
            is_active: init.1,
        }
    }

    fn init_widgets(
        &mut self,
        _index: &DynamicIndex,
        root: Self::Root,
        _returned_widget: &<Self::ParentWidget as relm4::factory::FactoryView>::ReturnedWidget,
        sender: FactorySender<Self>,
    ) -> Self::Widgets {
        let widgets = view_output!();

        // Set wallpaper preview (first monitor's wallpaper)
        if let Some(wallpaper_path) = self.profile.monitor_wallpapers.values().next() {
            if wallpaper_path.exists() {
                widgets.wallpaper_picture.set_file(Some(&gio::File::for_path(wallpaper_path)));
            }
        }

        // Set theme color preview if theme_id exists
        if let Some(ref theme_id) = self.profile.theme_id {
            if let Ok(themes) = theme_storage::load_themes() {
                if let Some(theme) = themes.iter().find(|t| &t.theme_id == theme_id) {
                    build_mini_color_preview(&widgets.color_box, theme);
                }
            }
        }

        widgets
    }
}

/// Build a small color preview (4 colors in a row)
fn build_mini_color_preview(container: &gtk::Box, theme: &crate::models::Theme) {
    let colors = theme.preview_colors();
    let row = gtk::Box::new(gtk::Orientation::Horizontal, 2);
    row.set_homogeneous(true);

    for color_str in colors.iter().take(4) {
        let area = gtk::DrawingArea::new();
        area.set_content_height(20);
        area.set_content_width(20);

        let color = parse_hex_color(color_str);
        area.set_draw_func(move |_, cr, width, height| {
            cr.set_source_rgb(color.0, color.1, color.2);
            cr.rectangle(0.0, 0.0, width as f64, height as f64);
            let _ = cr.fill();
        });

        row.append(&area);
    }

    container.append(&row);
}

fn parse_hex_color(hex: &str) -> (f64, f64, f64) {
    let hex = hex.trim_start_matches('#');
    if hex.len() >= 6 {
        let r = u8::from_str_radix(&hex[0..2], 16).unwrap_or(0) as f64 / 255.0;
        let g = u8::from_str_radix(&hex[2..4], 16).unwrap_or(0) as f64 / 255.0;
        let b = u8::from_str_radix(&hex[4..6], 16).unwrap_or(0) as f64 / 255.0;
        (r, g, b)
    } else {
        (0.5, 0.5, 0.5)
    }
}
```

Update components/mod.rs:
- Add `pub mod profile_card;`
  </action>
  <verify>
cargo check --package vulcan-appearance-manager 2>&1 | grep -E "(error|profile_card)" || echo "profile_card OK"
  </verify>
  <done>
ProfileItem factory component exists with theme color preview, wallpaper thumbnail, Load and Delete buttons emitting ProfileCardOutput messages
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ProfileView container component</name>
  <files>
    vulcan-appearance-manager/src/components/profile_view.rs
    vulcan-appearance-manager/src/components/mod.rs
  </files>
  <action>
Create profile_view.rs with the Profiles tab container:

```rust
use gtk::prelude::*;
use relm4::prelude::*;
use relm4::factory::FactoryVecDeque;

use crate::models::{UnifiedProfile, BindingMode};
use crate::services::profile_storage;
use super::profile_card::{ProfileItem, ProfileCardOutput};

#[derive(Debug)]
pub enum ProfileViewMsg {
    Refresh,
    SaveCurrent,
    LoadProfile(String),
    DeleteProfile(String),
    ConfirmDelete(String),
    UpdateCurrentState {
        theme_id: Option<String>,
        wallpapers: std::collections::HashMap<String, std::path::PathBuf>,
        binding_mode: BindingMode,
    },
    SaveDialogResponse(String),  // profile name from dialog
}

#[derive(Debug)]
pub enum ProfileViewOutput {
    ShowToast(String),
    LoadProfile(UnifiedProfile),
    ProfileDeleted(String),
}

pub struct ProfileViewModel {
    profiles: FactoryVecDeque<ProfileItem>,
    current_state: Option<CurrentAppState>,
    active_profile: Option<String>,
}

#[derive(Debug, Clone)]
struct CurrentAppState {
    theme_id: Option<String>,
    wallpapers: std::collections::HashMap<String, std::path::PathBuf>,
    binding_mode: BindingMode,
}

#[relm4::component(pub)]
impl SimpleComponent for ProfileViewModel {
    type Init = ();
    type Input = ProfileViewMsg;
    type Output = ProfileViewOutput;

    view! {
        gtk::Box {
            set_orientation: gtk::Orientation::Vertical,
            set_spacing: 12,
            set_margin_all: 12,

            // Header with Save button
            gtk::Box {
                set_orientation: gtk::Orientation::Horizontal,
                set_spacing: 8,

                gtk::Label {
                    set_markup: "<b>Saved Profiles</b>",
                    set_halign: gtk::Align::Start,
                    set_hexpand: true,
                },

                gtk::Button {
                    set_icon_name: "list-add-symbolic",
                    set_label: "Save Current",
                    set_tooltip_text: Some("Save current appearance as profile"),
                    connect_clicked => ProfileViewMsg::SaveCurrent,
                },

                gtk::Button {
                    set_icon_name: "view-refresh-symbolic",
                    set_tooltip_text: Some("Refresh profiles"),
                    connect_clicked => ProfileViewMsg::Refresh,
                },
            },

            // Profiles grid
            gtk::ScrolledWindow {
                set_vexpand: true,
                set_hscrollbar_policy: gtk::PolicyType::Never,

                #[local_ref]
                profiles_box -> gtk::FlowBox {
                    set_selection_mode: gtk::SelectionMode::None,
                    set_homogeneous: true,
                    set_min_children_per_line: 2,
                    set_max_children_per_line: 4,
                    set_row_spacing: 8,
                    set_column_spacing: 8,
                },
            },

            // Empty state
            #[name = "empty_state"]
            gtk::Box {
                set_orientation: gtk::Orientation::Vertical,
                set_spacing: 8,
                set_valign: gtk::Align::Center,
                set_vexpand: true,

                gtk::Image {
                    set_icon_name: Some("folder-symbolic"),
                    set_pixel_size: 64,
                    add_css_class: "dim-label",
                },

                gtk::Label {
                    set_label: "No saved profiles",
                    add_css_class: "dim-label",
                },

                gtk::Label {
                    set_label: "Save your current appearance to create one",
                    add_css_class: "dim-label",
                },
            },
        }
    }

    fn init(
        _init: Self::Init,
        root: Self::Root,
        sender: ComponentSender<Self>,
    ) -> ComponentParts<Self> {
        let profiles = FactoryVecDeque::builder()
            .launch(gtk::FlowBox::new())
            .forward(sender.input_sender(), |msg| {
                match msg {
                    ProfileCardOutput::Load(name) => ProfileViewMsg::LoadProfile(name),
                    ProfileCardOutput::Delete(name) => ProfileViewMsg::DeleteProfile(name),
                }
            });

        let model = ProfileViewModel {
            profiles,
            current_state: None,
            active_profile: None,
        };

        let profiles_box = model.profiles.widget();
        let widgets = view_output!();

        // Initial load
        sender.input(ProfileViewMsg::Refresh);

        ComponentParts { model, widgets }
    }

    fn update(&mut self, msg: Self::Input, sender: ComponentSender<Self>) {
        match msg {
            ProfileViewMsg::Refresh => {
                self.load_profiles();
            }

            ProfileViewMsg::SaveCurrent => {
                self.show_save_dialog(sender.clone());
            }

            ProfileViewMsg::SaveDialogResponse(name) => {
                if let Some(ref state) = self.current_state {
                    let profile = UnifiedProfile {
                        name: name.clone(),
                        description: String::new(),
                        theme_id: state.theme_id.clone(),
                        monitor_wallpapers: state.wallpapers.clone(),
                        binding_mode: state.binding_mode.clone(),
                    };

                    match profile_storage::save_unified_profile(&profile) {
                        Ok(_) => {
                            sender.output(ProfileViewOutput::ShowToast(
                                format!("Saved profile: {}", name)
                            )).ok();
                            self.active_profile = Some(name);
                            self.load_profiles();
                        }
                        Err(e) => {
                            sender.output(ProfileViewOutput::ShowToast(
                                format!("Failed to save: {}", e)
                            )).ok();
                        }
                    }
                } else {
                    sender.output(ProfileViewOutput::ShowToast(
                        "No current state to save".to_string()
                    )).ok();
                }
            }

            ProfileViewMsg::LoadProfile(name) => {
                match profile_storage::load_unified_profile(&name) {
                    Ok(profile) => {
                        self.active_profile = Some(name);
                        self.load_profiles();  // Refresh to show active badge
                        sender.output(ProfileViewOutput::LoadProfile(profile)).ok();
                    }
                    Err(e) => {
                        sender.output(ProfileViewOutput::ShowToast(
                            format!("Failed to load: {}", e)
                        )).ok();
                    }
                }
            }

            ProfileViewMsg::DeleteProfile(name) => {
                // Show confirmation dialog
                sender.input(ProfileViewMsg::ConfirmDelete(name));
            }

            ProfileViewMsg::ConfirmDelete(name) => {
                match profile_storage::delete_unified_profile(&name) {
                    Ok(_) => {
                        if self.active_profile.as_ref() == Some(&name) {
                            self.active_profile = None;
                        }
                        self.load_profiles();
                        sender.output(ProfileViewOutput::ProfileDeleted(name)).ok();
                    }
                    Err(e) => {
                        sender.output(ProfileViewOutput::ShowToast(
                            format!("Failed to delete: {}", e)
                        )).ok();
                    }
                }
            }

            ProfileViewMsg::UpdateCurrentState { theme_id, wallpapers, binding_mode } => {
                self.current_state = Some(CurrentAppState {
                    theme_id,
                    wallpapers,
                    binding_mode,
                });
            }
        }
    }
}

impl ProfileViewModel {
    fn load_profiles(&mut self) {
        let mut guard = self.profiles.guard();
        guard.clear();

        if let Ok(names) = profile_storage::list_unified_profiles() {
            for name in names {
                if let Ok(profile) = profile_storage::load_unified_profile(&name) {
                    let is_active = self.active_profile.as_ref() == Some(&name);
                    guard.push_back((profile, is_active));
                }
            }
        }
    }

    fn show_save_dialog(&self, sender: ComponentSender<Self>) {
        // Simple dialog to get profile name
        // Auto-suggest based on theme name if available
        let suggested_name = self.current_state
            .as_ref()
            .and_then(|s| s.theme_id.clone())
            .unwrap_or_else(|| "My Profile".to_string());

        // Create simple entry dialog
        let dialog = gtk::Dialog::builder()
            .title("Save Profile")
            .modal(true)
            .build();

        let content = dialog.content_area();
        content.set_margin_all(16);
        content.set_spacing(12);

        let label = gtk::Label::new(Some("Profile name:"));
        label.set_halign(gtk::Align::Start);
        content.append(&label);

        let entry = gtk::Entry::new();
        entry.set_text(&suggested_name);
        entry.set_activates_default(true);
        content.append(&entry);

        dialog.add_button("Cancel", gtk::ResponseType::Cancel);
        dialog.add_button("Save", gtk::ResponseType::Accept);

        let entry_clone = entry.clone();
        dialog.connect_response(move |dialog, response| {
            if response == gtk::ResponseType::Accept {
                let name = entry_clone.text().to_string().trim().to_string();
                if !name.is_empty() {
                    sender.input(ProfileViewMsg::SaveDialogResponse(name));
                }
            }
            dialog.close();
        });

        dialog.present();
    }
}
```

Update components/mod.rs:
- Add `pub mod profile_view;`
- Add `pub use profile_view::{ProfileViewModel, ProfileViewMsg, ProfileViewOutput};`
  </action>
  <verify>
cargo check --package vulcan-appearance-manager 2>&1 | grep -E "(error|profile_view)" || echo "profile_view OK"
  </verify>
  <done>
ProfileViewModel component exists with FlowBox of ProfileItems, Save Current button shows dialog, Load/Delete actions work, empty state shown when no profiles
  </done>
</task>

</tasks>

<verification>
Components compile:
```bash
cd /home/evan/VulcanOS/vulcan-appearance-manager && cargo check
```

Modules exported:
```bash
grep -n "profile_card\|profile_view" vulcan-appearance-manager/src/components/mod.rs
```

ProfileViewOutput messages exist:
```bash
grep -n "LoadProfile\|ProfileDeleted" vulcan-appearance-manager/src/components/profile_view.rs
```
</verification>

<success_criteria>
- ProfileItem factory shows profile name, theme colors, wallpaper thumbnail
- ProfileItem has Load and Delete buttons with correct output messages
- ProfileView contains FlowBox of ProfileItems
- ProfileView has "Save Current" button that shows name entry dialog
- ProfileView handles Load, Delete, and Save operations
- Empty state shown when no profiles exist
- No compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-theme-wallpaper-binding/08-05-SUMMARY.md`
</output>
