---
phase: 06-foundation-architecture
plan: 05
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - vulcan-appearance-manager/src/services/theme_parser.rs
autonomous: true

must_haves:
  truths:
    - "Theme parser rejects files containing shell execution patterns ($(...), backticks, eval)"
    - "Theme parser validates THEME_ID matches safe pattern: alphanumeric with hyphens/underscores"
    - "Theme parser validates color values match hex pattern: #RRGGBB"
    - "Theme parser rejects files missing required variables (THEME_NAME, THEME_ID)"
    - "Theme parser returns descriptive errors for each validation failure"
    - "Existing parse and serialize functionality is preserved (not broken)"
  artifacts:
    - path: "vulcan-appearance-manager/src/services/theme_parser.rs"
      provides: "Hardened bash theme parser with validation"
      contains: "pub fn validate_theme"
      min_lines: 100
  key_links:
    - from: "vulcan-appearance-manager/src/services/theme_parser.rs"
      to: "regex crate"
      via: "lazy_static regex patterns"
      pattern: "static ref HEX_COLOR_RE"
    - from: "vulcan-appearance-manager/src/services/theme_parser.rs"
      to: "theme_parser::parse_theme_content"
      via: "parse_and_validate calls parse then validate"
      pattern: "pub fn parse_and_validate"
---

<objective>
Harden the theme bash parser with validation: dangerous pattern detection, required variable checks, hex color validation, and safe theme_id enforcement.

Purpose: The existing parser (from vulcan-theme-manager) accepts any input without validation. Since parsed values are later used in CLI commands (`vulcan-theme set <theme_id>`), a crafted theme file could inject unexpected values. This plan adds defense-in-depth validation: reject dangerous shell patterns, validate theme_id format, validate color hex values, and enforce required variables. This is a security hardening -- no new features.

Output: An enhanced theme_parser.rs with validate_theme() and parse_and_validate() functions, plus comprehensive tests.
</objective>

<execution_context>
@/home/evan/.claude/get-shit-done/workflows/execute-plan.md
@/home/evan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-foundation-architecture/06-CONTEXT.md
@.planning/phases/06-foundation-architecture/06-RESEARCH.md
@.planning/phases/06-foundation-architecture/06-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add validation regexes and validate_theme function</name>
  <files>vulcan-appearance-manager/src/services/theme_parser.rs</files>
  <action>
  Enhance the existing `theme_parser.rs` by ADDING to it (preserve all existing code):

  **1. Add new regex patterns to the lazy_static block:**
  ```rust
  /// Valid hex color: #RRGGBB (6-digit hex only, not 3-digit or 8-digit)
  static ref HEX_COLOR_RE: Regex = Regex::new(r"^#[0-9a-fA-F]{6}$").unwrap();

  /// Valid theme ID: starts with alphanumeric, then alphanumeric/hyphen/underscore
  static ref THEME_ID_RE: Regex = Regex::new(r"^[a-zA-Z0-9][a-zA-Z0-9_-]*$").unwrap();
  ```

  **2. Add constants for required and color variables:**
  ```rust
  /// Variables that every valid theme must define
  const REQUIRED_VARS: &[&str] = &["THEME_NAME", "THEME_ID"];

  /// Fields that should contain valid hex colors (when non-empty)
  const COLOR_FIELDS: &[&str] = &[
      "bg_primary", "bg_secondary", "bg_tertiary", "bg_surface",
      "fg_primary", "fg_secondary", "fg_muted",
      "accent", "accent_alt",
      "red", "green", "yellow", "blue", "purple", "cyan", "orange", "pink",
      "bright_red", "bright_green", "bright_yellow", "bright_blue", "bright_purple", "bright_cyan",
      "border_active", "border_inactive", "selection", "cursor",
      "gradient_start", "gradient_end",
  ];
  ```

  **3. Add dangerous pattern check function:**
  ```rust
  /// Check for shell execution patterns that should never appear in theme files.
  /// Theme files are bash scripts but we parse them with regex -- we never execute them.
  /// This is defense-in-depth against files crafted to exploit downstream consumers.
  fn check_dangerous_patterns(content: &str, path_display: &str) -> Result<()> {
  ```
  Reject if content contains any of:
  - `$(` -- command substitution
  - Backtick characters -- legacy command substitution
  - `eval ` -- eval command
  - `source ` -- source command
  - `exec ` -- exec command
  - `| ` (pipe) -- pipeline execution

  Return `anyhow::bail!("Theme file contains dangerous shell pattern '...' (not allowed): {path}")` with the specific pattern found.

  **4. Add validate_theme function:**
  ```rust
  /// Validate a parsed Theme for completeness and correctness.
  /// Returns Ok(()) if valid, Err with description if invalid.
  pub fn validate_theme(theme: &Theme) -> Result<()> {
  ```
  Checks:
  - theme_name is not empty (after trim)
  - theme_id is not empty and matches THEME_ID_RE
  - For each color field in the Theme struct: if the value is non-empty AND not a default empty string, validate it matches HEX_COLOR_RE

  For color field validation, use a helper that maps field name to Theme struct field value. The simplest approach: create a vec of (field_name, &value) tuples and iterate. Example:
  ```rust
  let color_checks: Vec<(&str, &str)> = vec![
      ("bg_primary", &theme.bg_primary),
      ("bg_secondary", &theme.bg_secondary),
      // ... all color fields
  ];
  for (name, value) in color_checks {
      if !value.is_empty() && !HEX_COLOR_RE.is_match(value) {
          anyhow::bail!("Invalid hex color for {}: '{}' (expected #RRGGBB)", name, value);
      }
  }
  ```

  **5. Add parse_and_validate function:**
  ```rust
  /// Parse and validate a theme file. Returns Err if file is malformed or invalid.
  /// This is the preferred entry point -- use instead of parse_theme_file for untrusted input.
  pub fn parse_and_validate(path: &Path) -> Result<Theme> {
  ```
  Steps:
  1. Read file content
  2. Call check_dangerous_patterns()
  3. Call parse_theme_content() (existing function)
  4. Check required variables are present (theme_name not empty, theme_id not empty)
  5. Call validate_theme()
  6. Return the validated Theme

  **Important:** Do NOT modify the existing `parse_theme_file()` or `parse_theme_content()` functions. They remain as-is for backward compatibility. `parse_and_validate()` is a NEW function that wraps them with validation. Callers can choose which to use.

  Do NOT modify the existing tests. Add new tests in Task 2.
  </action>
  <verify>
  `cargo check --manifest-path vulcan-appearance-manager/Cargo.toml` passes.
  ```bash
  grep "pub fn validate_theme" vulcan-appearance-manager/src/services/theme_parser.rs
  grep "pub fn parse_and_validate" vulcan-appearance-manager/src/services/theme_parser.rs
  grep "HEX_COLOR_RE" vulcan-appearance-manager/src/services/theme_parser.rs
  grep "THEME_ID_RE" vulcan-appearance-manager/src/services/theme_parser.rs
  grep "check_dangerous_patterns" vulcan-appearance-manager/src/services/theme_parser.rs
  ```
  </verify>
  <done>
  - HEX_COLOR_RE and THEME_ID_RE regex patterns added
  - check_dangerous_patterns() function detects 6 dangerous patterns
  - validate_theme() validates theme_id format and color hex values
  - parse_and_validate() wraps parse + validate for untrusted input
  - Existing functions (parse_theme_file, parse_theme_content, serialize_theme) unchanged
  - Module compiles
  </done>
</task>

<task type="auto">
  <name>Task 2: Add validation unit tests</name>
  <files>vulcan-appearance-manager/src/services/theme_parser.rs</files>
  <action>
  Add new tests to the existing `#[cfg(test)] mod tests` block in theme_parser.rs. Keep the existing 2 tests (test_parse_theme, test_serialize_theme) and add:

  **Dangerous pattern tests:**
  - `test_rejects_command_substitution`: Content with `$(whoami)` is rejected by parse_and_validate
  - `test_rejects_backtick`: Content with backtick is rejected
  - `test_rejects_eval`: Content with `eval ` is rejected
  - `test_rejects_pipe`: Content with `| ` is rejected

  **Required variable tests:**
  - `test_rejects_missing_theme_name`: Valid content but THEME_NAME missing/empty -> Err
  - `test_rejects_missing_theme_id`: Valid content but THEME_ID missing/empty -> Err

  **Theme ID validation tests:**
  - `test_valid_theme_id`: "my-awesome-theme_v2" is valid
  - `test_rejects_theme_id_with_spaces`: "my theme" is rejected
  - `test_rejects_theme_id_with_semicolons`: "theme;rm -rf /" is rejected
  - `test_rejects_theme_id_starting_with_hyphen`: "-theme" is rejected

  **Color validation tests:**
  - `test_valid_hex_colors`: Theme with valid #RRGGBB colors passes validation
  - `test_rejects_invalid_hex_color`: Theme with "not-a-color" in bg_primary fails
  - `test_rejects_3_digit_hex`: "#fff" is rejected (must be 6 digits)
  - `test_allows_empty_color_fields`: Empty string color fields pass (they use defaults)

  **Integration tests:**
  - `test_parse_and_validate_valid_file`: Write a temp file with valid theme content, parse_and_validate succeeds. Use a well-formed theme string with all required fields.
  - `test_parse_and_validate_dangerous_file`: Write a temp file with $(evil), parse_and_validate fails.

  For file-based tests, use `std::io::Write` with `tempfile` or write to a temp path. Since tempfile crate is not a dependency, use `std::env::temp_dir()` to create temp files and clean up in the test.

  **Important:** Each test should verify the specific error message contains relevant info (use `.unwrap_err().to_string().contains("pattern")` or similar).

  Keep the existing 2 tests exactly as they are. Append new tests after them.
  </action>
  <verify>
  Run all parser tests:
  ```bash
  cargo test --manifest-path vulcan-appearance-manager/Cargo.toml -- theme_parser
  ```
  All tests must pass. Expect 2 existing + 16 new = 18 tests total.
  </verify>
  <done>
  - 16 new tests covering dangerous patterns, required variables, theme_id format, color validation, and integration
  - All 18 tests pass (2 existing + 16 new)
  - Error messages are descriptive and specific
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `cargo test --manifest-path vulcan-appearance-manager/Cargo.toml -- theme_parser` passes all 18 tests
2. `cargo check --manifest-path vulcan-appearance-manager/Cargo.toml` passes
3. Dangerous patterns ($(), backtick, eval, source, exec, pipe) are detected and rejected
4. Invalid theme_ids (spaces, semicolons, leading hyphen) are rejected
5. Invalid hex colors (3-digit, non-hex, missing #) are rejected
6. Missing required variables (THEME_NAME, THEME_ID) are rejected
7. Valid themes still parse correctly (existing tests unchanged and passing)
</verification>

<success_criteria>
- Theme parser hardens against shell injection patterns
- Theme ID format enforced for safe use in CLI commands
- Color values validated as proper hex
- Required variables enforced
- All validation errors are descriptive
- Existing parsing behavior preserved (backward compatible)
- 18 tests pass covering all validation paths
</success_criteria>

<output>
After completion, create `.planning/phases/06-foundation-architecture/06-05-SUMMARY.md`
</output>
